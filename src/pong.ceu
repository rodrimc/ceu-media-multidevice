#include "mars/mars-media.ceu"

native/pre do
  ##include <math.h>
end

native
  _ceil,
;

var int amount = 10;
var int width = 600;
var int height = 400;

var int img_width = 30;
var int img_height = 100;

var int ball_width = 30;
var int ball_height = 30;

data Direction with
  var float x;
  var float y;
end;

var int turn = 1;
var int wall = 1;

var bool have_won = _;
event (void) round_ended;

code/tight
Compute_Collision (var& IPlayer ball, var &IPlayer green,
    var& IPlayer red, var& Direction dir, var& float speed) -> void do

  var int x = call Player_Get_Int (&ball, "x");
  var int y = call Player_Get_Int (&ball, "y");

  var int green_x = call Player_Get_Int (&green, "x");
  var int green_y = call Player_Get_Int (&green, "y");

  var int red_x = call Player_Get_Int (&red, "x");
  var int red_y = call Player_Get_Int (&red, "y");

  if (outer.turn == -1 and x < outer.img_width  and
      y >= green_y and y <= green_y + outer.img_height) or
     (outer.turn == 1  and
      x > outer.width - (outer.img_width + outer.ball_width) and
      y >= red_y and y <= red_y + outer.img_height) then
    dir.x = dir.x * -1;
    speed = speed + 0.05;
    outer.turn = outer.turn * -1;
  end

  if (y <= 0 and outer.wall == 1) or
     (y + outer.ball_height >= outer.height and outer.wall == -1) then
    dir.y = dir.y * -1;
    outer.wall = outer.wall * -1;
  end
end

code/tight
Update (var& IPlayer ball, var& Direction dir, var float speed,
    var float time_diff) -> void do

  var int x = call Player_Get_Int (&ball, "x");
  var int y = call Player_Get_Int (&ball, "y");

  var int newx = x + (_ceil (dir.x * speed * time_diff) as int);
  var int newy = y + (_ceil (dir.y * speed * time_diff) as int);

  call Player_Set_Int (&ball, "x", newx);
  call Player_Set_Int (&ball, "y", newy);
end

var Media.Image green = val MEDIA_IMAGE ([] .. "resources/green.png");
var Media.Image red = val MEDIA_IMAGE ([] .. "resources/red.png");
var Media.Image blue = val MEDIA_IMAGE ([] .. "resources/blue.png");

green.region.y = height/2 - img_height/2;

red.region.x = width - img_width;
red.region.y = height/2 - img_height/2;

blue.region.x = img_width + 20;
blue.region.y = height/2 - 15;

var& IScene scene;
var& IPlayer p_green;
var& IPlayer p_red;
var& IPlayer p_ball;

var Region text_region = val Region (0, height - 200, 600, 200, 2);

watching Scene (Size (600, 400)) -> (&scene),
         Play (&scene, &green) -> (&p_green),
         Play (&scene, &red) -> (&p_red),
         Play (&scene, &blue) -> (&p_ball)
do
  var& IPlayer self;
  var& IPlayer opponent;
  var uint color;
  vector[] byte text = [] .. "Your color is ";
  if call Get_Device_Id () % 2 == 0 then
    color = 0xff00ff00;
    text = text .. "green";
    self = &p_green;
    opponent = &p_red;
  else
    color = 0xffff0000;
    text = text .. "red";
    self = &p_red;
    opponent = &p_green;
  end

  par/or do
    var Media.Text display = val Media.Text ([] .. text, [] .. "sans bold 30",
          text_region, color);

    await Play (&scene, &display);
  with
    var _char_ptr_ext key;
    var bool press;
    every (_, key, press) in CM_SCENE_KEY do
      if press then
        var& IPlayer p;
        if call Get_Device_Id () == call Get_Event_Device_Id () then
          p = &self;
        else
          p = &opponent;
        end
        var int y = call Player_Get_Int (&p, "y");
        if _strcmp (key, "Up") == 0  and y - amount >= 0 then
          call Player_Set_Int (&p, "y", y - amount);
        else/if _strcmp (key, "Down") == 0 and
            y + amount + img_height <= height then
          call Player_Set_Int (&p, "y", y + amount);
        end
      end
    end
  with
    var Direction dir = val Direction (2.5, -3);
    var int tick = 30;
    var float speed = 0.4;
    every (tick)ms do
      call Update (&p_ball, &dir, speed, tick * 0.1);
      call Compute_Collision (&p_ball, &p_green, &p_red, &dir, &speed);

      var int x = call Player_Get_Int (&p_ball, "x");

      if x <= 0 then
        if &&self == &&p_red then
          have_won = true;
        else
          have_won = false;
        end
        emit round_ended;
      else/if x >= width then
        if &&self == &&p_red then
          have_won = false;
        else
          have_won = true;
        end
        emit round_ended;
      end
    end
  with
    await round_ended;
  end

  var Media.Text m_end;
  if have_won then
    m_end = val MEDIA_TEXT ([] .. "Congrats, you won!");
  else
    m_end = val MEDIA_TEXT ([] .. "Game Over!");
  end

  m_end.region = text_region;
  watching 5s do
    await Play (&scene, &m_end);
  end
end

escape 0;
