#include "multidevice.ceu"

#include "media/media.ceu"
#define SESSION 0

event (int) joined;
event (u64, bool) do_seek;
event (u64) do_pause;
event (void) do_resume;

var bool ok = true;
var int id = -1;

vector[] byte msg = [] .. "return {code=" .. [[ tostring (@JOIN) ]];

var& _uv_tcp_t tcp;
event& void connected;
watching UV_TCP_Connect (LOCALHOST, 8888) -> (tcp, connected)
do
  await connected;

  msg = msg .. ",session=" .. [[ tostring (@SESSION) ]];

  /* send JOIN message */
  var u64 msg_ts = _now();
  msg = msg .. ",timestamp=" .. [[ tostring (@msg_ts) ]] .. "}\n";

  await UV_TCP_Write(&tcp, &msg);

  par/or do
    loop do
      vector [BUFF_SIZE] byte buff;
      var int code_ = _;

      /* await message */
      await UV_TCP_ReadLine(&tcp, &buff);
      var u64 msg_received_time = _now ();
      _printf ("[player (%d)] read: %s", id, &&buff[0]);

      /* parse message */
      [[ TABLE =  load (@buff)()]]

      code_ = [[ TABLE.code ]];
      if code_ == JOIN then
        /* JOIN REPLY */
        var int reply = [[ TABLE.reply ]];

        if reply != OK then
          _printf ("[player (%d)] I've received an error\n", id);
          break;
        end

        id = [[ TABLE.id ]];
        _printf ("[player (%d)] My id: %d\n", id, id);

        emit joined (id);

      else/if code_ == PAUSE then
        /* PAUSE MESSAGE*/
        _printf ("[player (%d)] pause\n", id);
        var int from = [[ TABLE.from ]];

        var u64 pause_offset = [[ TABLE.pause_time ]];

        if (from != id) then
          emit do_pause (pause_offset);
        end
      else
        _printf ("[player (%d)] unknown code\n", id);
      end
    end
  with
    await joined;
    var int width = 640;
    var int height = 480;

    var Media.Video video = val Media.Video (
                                [] .. "resources/animGar.mp4",
                                Region (0, 0, 0, width, height), 
                                1.0, 
                                1.0);

    var& IScene scene;
    var& IPlay p;

    watching Scene (Size(width, height)) -> (scene),
             Play (&scene, &video) -> (p)
    do
      call Scene_Set_Tick_Interval (&scene, 30 * NS);
      par do
        loop do
          var bool press;
          var _char_ptr_ext str;
          (str, press) = await scene.key;
          if press then
            if (_strcmp (str, "q") == 0) then
              emit scene.quit;
            else/if (_strcmp(str, "space") == 0) then
              var u64 running_time = call Play_Get_Running_Time (&p);
              call Scene_Pause (&scene);

              msg = [] .. "return {code=" .. [[ tostring (@PAUSE) ]];
              msg = msg .. ",pause=" .. [[ tostring (@running_time) ]];

              var u64 now = _now();
              msg = msg .. ",timestamp=" .. [[ tostring (@now) ]];
              msg = msg .. "}\n";

              await UV_TCP_Write(&tcp, &msg);
            end
          end
        end
      with
        var u64 time = await do_pause;
        _printf ("[player (%d)] pause offset: %llu\n", id, time);

        call Play_Seek (&p, time, false);
        await p.sought;

        /* This should result in differece of at most 2 frames*/
        await scene.tick;
        await scene.tick;

        _printf ("[player (%d)] freezing scene\n", id);
        call Scene_Pause(&scene);
        await FOREVER;
      end
    end
  end
end

escape 0;
