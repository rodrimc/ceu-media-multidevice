#ifndef _CEU_MULTIDEVICE
#define _CEU_MULTIDEVICE

#include "uv.ceu"
#include "media.ceu"
#include "synchronizer.ceu"

#define LOCALHOST "0.0.0.0"
#define PORT 8888
#define BACKLOG 128
#define BUFF_SIZE 256

/* MESSAGE CODES */
#define JOIN 1 

/* REPLY CODES */
#define OK 0
#define ERROR -1

native/pre do
  ##include <time.h>

  long long unsigned int now (void)
  {
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long unsigned int)ts.tv_sec * 1000000000L + ts.tv_nsec;
  }

end

native @nohold _strtoull ();

class Connection with
  var _uv_tcp_t& server;
  var u64 &start_time;
do
  // CLIENT
  var _uv_tcp_t&? client_;
  finalize
    client_ = &_malloc(sizeof(_uv_tcp_t));
  with
      // free after uv_close
  end
  var _uv_tcp_t& client = &client_!;
  _ceu_uv_tcp_init (&&client)
    finalize with
      _ceu_uv_close ((_uv_handle_t&&)&&client);
    end;

  // ACCEPT
  var int ret = _uv_accept ((_uv_stream_t&&)&&server,(_uv_stream_t&&)&&client);
  _assert (ret == 0);

  var uint session = 0;

  par/or do
    var _uv_stream_t&& s;
    var int err;
    (s,err) = await UV_ERROR until (s==(_uv_stream_t&&)&&client);
  with
    loop do
      var char[] msg;
      var int code;

      do UV_Stream_ReadLine.build(&_UV_STREAM_ALIAS(client), &msg);
      var u64 msg_received_time = _now();
      _printf ("%s\n", &&msg[0]);
      [[ TABLE =  load (@msg)()]]

      /*
        The following line isn't working because CÃ©u is returning an int32
        istead of an uint64.
        var u64 ts = [[ TABLE.timestamp ]];

        temporary workaround: convert to msg and then to uint64
        */
      var char [] tmp = [] .. "";
      tmp = [[ tostring(TABLE.timestamp) ]];

      var u64 delay_estimation = msg_received_time - 
                                        _strtoull (&&tmp[0], null, 10);
      _printf ("current delay estimation: %llu\n", delay_estimation);

      code = [[ TABLE.code ]];

      if code == JOIN then
        var int id = 0;

        session = [[ TABLE.session ]];

        /* code */
        tmp = [] .. "";
        tmp = [[ tostring (@JOIN) ]];
        msg = [] .. "return {code=" .. tmp;

        /* reply */
        tmp = [] .. "";
        tmp = [[ tostring (@OK) ]];
        msg = [] .. msg .. ",reply=" .. tmp;

        /* id */
        tmp = [] .. "";
        tmp = [[ tostring (@id) ]];
        msg = [] .. msg .. ",id=" .. tmp;

        /* timestamp */
        var u64 msg_ts = _now();
        tmp = [] .. "";
        tmp = [[ tostring (@msg_ts) ]];
        msg = [] .. msg .. ",timestamp=" .. tmp;

        /* seek */
        var u64 toseek = 0;
        if start_time == 0 then
          start_time = msg_ts + delay_estimation;
          /* considering that:
          /* i) start_time == time the device receives this reply */ 
          /* ii) device starts as soon as it receives this reply */
        else
          toseek = msg_ts - start_time + delay_estimation;
        end

        tmp = [] .. "";
        tmp = [[ tostring (@toseek) ]];
        msg = [] .. msg .. ",seek=" .. tmp; 

        /* end */
        msg = [] .. msg .. "}\n";
      else
        _printf ("[connection] Unknown code\n");
      end

      _printf ("[server] reply: %s", &&msg[0]);

      do UV_Stream_Write.build(&_UV_STREAM_ALIAS(client), &msg);
    end
  end
end

class Server with
  var _char&& ip;
  var int port;
  var int backlog;
  function (@hold _char&& ip, int port, int backlog) => Server build;
do
  function (@hold _char&& ip, int port, int backlog) => Server build do
    this.ip     := ip;
    this.port    = port;
    this.backlog = backlog;
  end

  var _uv_tcp_t&? server_;
  finalize
    server_ = &_malloc(sizeof(_uv_tcp_t));
  with
      // free after uv_close
  end
  var _uv_tcp_t& server = &server_!;
  _ceu_uv_tcp_init(&&server)
    finalize with
      _ceu_uv_close((_uv_handle_t&&)&&server);
    end;

  var _sockaddr_in addr = _sockaddr_in();
  _uv_ip4_addr(this.ip, this.port, &&addr);
  _uv_tcp_bind(&&server, (_sockaddr&&)&&addr, 0);
  do
    var int ret = _ceu_uv_listen((_uv_stream_t&&)&&server, this.backlog);
    _assert(ret == 0);
  end
  _printf ("[server] Server started\n");
  _printf ("[server] Listening on port %d\n", this.port);

  var u64 start_time = 0;
  every (s,status) in UV_LISTEN do
    if s == (_uv_stream_t&&) &&server then
      _assert(status >= 0);
      _printf ("[server] New connection.\n");
      spawn Connection with
        this.server = &server;
        this.start_time = &start_time;
        /* this.syncs = &syncs; */
      end;
    end
  end
end

class Client with
    var _char&& ip;
    var int port;
    event int ok;

output:
    var _uv_tcp_t& tcp;

    function (@hold _char&& ip, int port)=>Client build;
do
    function (@hold _char&& ip, int port)=>Client build do
        this.ip  := ip;
        this.port = port;
    end

    var _uv_tcp_t client = _uv_tcp_t();
    _ceu_uv_tcp_init(&&client)
        finalize with
            _uv_close((_uv_handle_t&&)&&client, null);
        end;
    this.tcp = &client;

    var _uv_connect_t&? connect;
    finalize
        connect = &_malloc(sizeof(_uv_connect_t));
    with
        // free on uv callback
    end

    var _sockaddr_in dest = _sockaddr_in();
    _uv_ip4_addr(this.ip, this.port, &&dest);
    _ceu_uv_tcp_connect(&&connect!, &&client, (_sockaddr&&)&&dest);

    var _uv_connect_t&& c;
    var int status;
    (c,status) = await UV_CONNECT until c==&&connect!;

    emit this.ok => status;
    await FOREVER;
end

#endif

