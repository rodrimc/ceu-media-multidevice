#ifndef _CEU_MULTIDEVICE
#define _CEU_MULTIDEVICE

#include "uv.ceu"
#include "media.ceu"
#include "synchronizer.ceu"

#define LOCALHOST "0.0.0.0"
#define PORT 8888
#define BACKLOG 128
#define BUFF_SIZE 256

/* MESSAGE CODES */
#define JOIN 1
#define UPDATE_START_TIME 2
#define PAUSE 3
#define RESUME 4

/* REPLY CODES */
#define OK 0
#define ERROR -1

native/pre do
  ##include <time.h>

  long long unsigned int now (void)
  {
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long unsigned int)ts.tv_sec * 1000000000L + ts.tv_nsec;
  }

end

native @nohold _strtoull ();

class Dummy with
  event (int, u64) notify_pause;
  event (int) notify_resume;
do
  await FOREVER;
end

class Connection with
  var _uv_tcp_t& server;
  var u64 &start_time;
  var int id;
  var Dummy &dummy;
do
  // CLIENT
  var _uv_tcp_t&? client_;
  finalize
    client_ = &_malloc(sizeof(_uv_tcp_t));
  with
      // free after uv_close
  end
  var _uv_tcp_t& client = &client_!;
  _ceu_uv_tcp_init (&&client)
    finalize with
      _ceu_uv_close ((_uv_handle_t&&)&&client);
    end;

  // ACCEPT
  var int ret = _uv_accept ((_uv_stream_t&&)&&server,(_uv_stream_t&&)&&client);
  _assert (ret == 0);

  var uint session = 0;

  par/or do
    var _uv_stream_t&& s;
    var int err;
    (s,err) = await UV_ERROR until (s==(_uv_stream_t&&)&&client);
  with
    loop do
      var char[] msg;
      var int code;

      do UV_Stream_ReadLine.build(&_UV_STREAM_ALIAS(client), &msg);
      var u64 msg_received_time = _now();
      _printf ("%s\n", &&msg[0]);
      [[ TABLE =  load (@msg)()]]

      /*
        The following line isn't working because CÃ©u is returning an int32
        istead of an uint64.
        var u64 ts = [[ TABLE.timestamp ]];

        temporary workaround: convert to msg and then to uint64
        */
      var char [] tmp = [] .. "";
      tmp = [[ tostring(TABLE.timestamp) ]];

      var u64 delay_estimation = msg_received_time -
                                        _strtoull (&&tmp[0], null, 10);
      _printf ("current delay estimation: %llu\n", delay_estimation);

      code = [[ TABLE.code ]];

      var bool send_reply = true;
      if code == JOIN then
        session = [[ TABLE.session ]];

        /* code */
        tmp = [] .. "";
        tmp = [[ tostring (@JOIN) ]];
        msg = [] .. "return {code=" .. tmp;

        /* reply */
        tmp = [] .. "";
        tmp = [[ tostring (@OK) ]];
        msg = [] .. msg .. ",reply=" .. tmp;

        /* id */
        tmp = [] .. "";
        tmp = [[ tostring (@id) ]];
        msg = [] .. msg .. ",id=" .. tmp;

        /* start time */
        var u64 tmp2 = start_time;
        tmp = [] .. "";
        tmp = [[ tostring (@tmp2) ]];
        msg = [] .. msg .. ",start=" .. tmp;

        /* timestamp */
        var u64 msg_ts = _now();
        tmp = [] .. "";
        tmp = [[ tostring (@msg_ts) ]];
        msg = [] .. msg .. ",timestamp=" .. tmp;

        /* end */
        msg = [] .. msg .. "}\n";
      else/if code == UPDATE_START_TIME then
        tmp = [] .. "";
        tmp = [[ tostring(TABLE.start) ]];

        start_time = _strtoull (&&tmp[0], null, 10);
        _printf ("[server (%d)] new start time: %llu\n", id, start_time);

        /* code */
        tmp = [] .. "";
        tmp = [[ tostring (@UPDATE_START_TIME) ]];
        msg = [] .. "return {code=" .. tmp;

        /* reply */
        tmp = [] .. "";
        tmp = [[ tostring (@OK) ]];
        msg = [] .. msg .. ",reply=" .. tmp;

        /* timestamp */
        var u64 msg_ts = _now();
        tmp = [] .. "";
        tmp = [[ tostring (@msg_ts) ]];
        msg = [] .. msg .. ",timestamp=" .. tmp;

        /* end */
        msg = [] .. msg .. "}\n";
      else/if code == PAUSE then
        tmp = [] .. "";
        tmp = [[ tostring(TABLE.pause) ]];

        var u64 pause_time = _strtoull (&&tmp[0], null, 10);
        _printf ("[server (%d)] pause time: %llu\n", id, pause_time);

        emit dummy.notify_pause => (id, pause_time);
        send_reply = false;
      else/if code == RESUME then
        emit dummy.notify_resume => (id);
        send_reply = false;
      else
        _printf ("[connection] Unknown code\n");
      end

      if (send_reply) then
        _printf ("[server (%d)] reply: %s", id, &&msg[0]);
        do UV_Stream_Write.build(&_UV_STREAM_ALIAS(client), &msg);
      end
    end
  with
    loop do
      var int i;
      var u64 time;
      (i, time) = await dummy.notify_pause;

      _printf ("%d: dummy(%d).notify_pause\n", id, i);
      var char [] tmp = [] .. "";
      var char [] msg = [] .. "";

      /* code */
      tmp = [[ tostring (@PAUSE) ]];
      msg = [] .. "return {code=" .. tmp;

      /* from */
      tmp = [] .. "";
      tmp = [[ tostring (@i) ]];
      msg = [] .. msg .. ",from=" .. tmp;

      /* pause time*/
      tmp = [] .. "";
      tmp = [[ tostring (@time) ]];
      msg = [] .. msg .. ",pause_time=" .. tmp;

      /* timestamp */
      var u64 msg_ts = _now();
      tmp = [] .. "";
      tmp = [[ tostring (@msg_ts) ]];
      msg = [] .. msg .. ",timestamp=" .. tmp;

      /* end */
      msg = [] .. msg .. "}\n";

      _printf ("[server (%d)] send: %s", id, &&msg[0]);
      do UV_Stream_Write.build(&_UV_STREAM_ALIAS(client), &msg);
    end
  with
    loop do
      var int i;
      i = await dummy.notify_resume;

      _printf ("%d: dummy(%d).notify_resume\n", id, i);
      var char [] tmp = [] .. "";
      var char [] msg = [] .. "";

      /* code */
      tmp = [[ tostring (@RESUME) ]];
      msg = [] .. "return {code=" .. tmp;

      /* from */
      tmp = [] .. "";
      tmp = [[ tostring (@i) ]];
      msg = [] .. msg .. ",from=" .. tmp;

      /* timestamp */
      var u64 msg_ts = _now();
      tmp = [] .. "";
      tmp = [[ tostring (@msg_ts) ]];
      msg = [] .. msg .. ",timestamp=" .. tmp;

      /* end */
      msg = [] .. msg .. "}\n";

      _printf ("[server (%d)] send: %s", id, &&msg[0]);
      do UV_Stream_Write.build(&_UV_STREAM_ALIAS(client), &msg);
    end
  end
end

class Server with
  var _char&& ip;
  var int port;
  var int backlog;
  function (@hold _char&& ip, int port, int backlog) => Server build;
do
  function (@hold _char&& ip, int port, int backlog) => Server build do
    this.ip     := ip;
    this.port    = port;
    this.backlog = backlog;
  end

  var _uv_tcp_t&? server_;
  finalize
    server_ = &_malloc(sizeof(_uv_tcp_t));
  with
      // free after uv_close
  end
  var _uv_tcp_t& server = &server_!;
  _ceu_uv_tcp_init(&&server)
    finalize with
      _ceu_uv_close((_uv_handle_t&&)&&server);
    end;

  var _sockaddr_in addr = _sockaddr_in();
  _uv_ip4_addr(this.ip, this.port, &&addr);
  _uv_tcp_bind(&&server, (_sockaddr&&)&&addr, 0);
  do
    var int ret = _ceu_uv_listen((_uv_stream_t&&)&&server, this.backlog);
    _assert(ret == 0);
  end
  _printf ("[server] Server started\n");
  _printf ("[server] Listening on port %d\n", this.port);

  var Dummy dummy;

  var int id = 0;
  var u64 start_time = 0;
  every (s,status) in UV_LISTEN do
    if s == (_uv_stream_t&&) &&server then
      _assert(status >= 0);
      _printf ("[server] New connection.\n");
      spawn Connection with
        this.server = &server;
        this.start_time = &start_time;
        this.id = id;
        this.dummy = &dummy;
        /* this.syncs = &syncs; */
      end;
      id = id + 1;
    end
  end
end

class Client with
    var _char&& ip;
    var int port;
    event int ok;

output:
    var _uv_tcp_t& tcp;

    function (@hold _char&& ip, int port)=>Client build;
do
    function (@hold _char&& ip, int port)=>Client build do
        this.ip  := ip;
        this.port = port;
    end

    var _uv_tcp_t client = _uv_tcp_t();
    _ceu_uv_tcp_init(&&client)
        finalize with
            _uv_close((_uv_handle_t&&)&&client, null);
        end;
    this.tcp = &client;

    var _uv_connect_t&? connect;
    finalize
        connect = &_malloc(sizeof(_uv_connect_t));
    with
        // free on uv callback
    end

    var _sockaddr_in dest = _sockaddr_in();
    _uv_ip4_addr(this.ip, this.port, &&dest);
    _ceu_uv_tcp_connect(&&connect!, &&client, (_sockaddr&&)&&dest);

    var _uv_connect_t&& c;
    var int status;
    (c,status) = await UV_CONNECT until c==&&connect!;

    emit this.ok => status;
    await FOREVER;
end

#endif

