#include "mars/util/mars-media.ceu"
#include "mars/client/mars-client.ceu"

native/pre do
__OUTPUT_TYPES__
end

native/pos do
  int MIRROR_OK = 0;
  char *ROLE_NAME = NULL;
  int ROLE_INDEX = -1;

	tceu_callback_ret evt_cb (int cmd,
														tceu_callback_arg p1,
														tceu_callback_arg p2,
														const char* filename,
														u32 line)
	{
    static int flag = 0;
    tceu_callback_ret ret = { .is_handled = 1 };
    switch (cmd)
    {
      case CEU_CALLBACK_STEP:
      {
        if (flag == 0)
        {
          char *device = "";
          char c;

          while ((c = getopt (CEU_APP.argc, CEU_APP.argv, "d:")) != -1)
          {
            switch (c)
            {
              case 'd':
              {
                device = optarg;
                break;
              }
            }
          }

          ceu_input (CEU_INPUT_INIT, &device);

          flag = 1;
        }

        if (MIRROR_OK == 1)
        {
          tceu_input_JOINED p = {ROLE_NAME, ROLE_INDEX};
          ceu_input (CEU_INPUT_JOINED, &p);

          MIRROR_OK = 0;
        }
        else
          ret.is_handled = 0;

        break;
      }
      case CEU_CALLBACK_OUTPUT:
      {
        char *type;
        u_args p;
__CALLBACK_OUTPUT_COND__
        tceu_input_IN input_p = {type, p};
        ceu_input (CEU_INPUT_IN, &input_p);
        break;
      }
      case CEU_CALLBACK_STOP:
      {
        if (ROLE_NAME)
          free (ROLE_NAME);
        break;
      }
      default:
        ret.is_handled = 0;
    }

    return ret;
  }

  void alloc_role_name (size_t size)
  {
    ROLE_NAME = malloc (size);
  }

  tceu_callback cb = { &evt_cb, NULL };
end

native/nohold
  _cb,
  _u_args,
  _ceu_callback_register,
  _alloc_role_name,
  _MIRROR_OK,
  _ROLE_NAME,
  _ROLE_INDEX
;

_ceu_callback_register (&&_cb);

input (_char&&) INIT;
input (_char&&, int) JOINED;

spawn do
  var _char&& role = await INIT;
  var Exception? e;
  catch e do
    _printf ("[client] role: %s\n", role);
    [[ CLIENT.role.name = @role ]]
  end
  if e? then
    _fprintf (_stderr, "[INIT error:] %s\n", e!.message);
  end
end

/* internal */
event (none) mirror_ok;

code/await Handle_Mapping (var _char&& evt, var&[] byte from,  var _char&& mapping) -> none;

par/or do
  var int min_peers = _;

  var Exception.Lua? e;
  catch e do
    [[
      CONFIG = {}
      min_peers = 1
      chunk = loadfile ('config.lua')
      if chunk then
        CONFIG = chunk ()

        min_peers = CONFIG.MIN_PEERS or min_peers
      end
    ]]
    min_peers = [[ min_peers ]];
  end
  if e? then
    _fprintf (_stderr, "[Load_Sync_Config error]: %s\n", e!.message);
  end

  var&? Client client = spawn Client (LOCALHOST, 0);
  watching client do
    await client.stub.all_set_up;

    pool [] Client_Send_Message send_message_pool;
    par do
      var uint id;
      var usize peers;
      (id, peers) = await client.stub.joined;
      _printf ("joined\n");
      /* device_id is defined in mars-media.ceu */
      device_id = id;
    with
      watching mirror_ok do
        var uint new_peer;
        var usize peers;
        every (new_peer, peers) in client.stub.new_peer do
          if (peers >= min_peers) then
            emit mirror_ok;
          end
        end
      end
    with
      pool[] Handle_Mapping mapping_pool;
      var[] byte evt = _;
      var[] int mapped = _;
      var[] int mapping = _;
      every client.stub.incoming_message do
        [[ print ('[APP(' .. tostring(@client.stub.id) .. ')] Message: ' ..
                                  @client.stub.message) ]]
        _log ("[APP(%u)] Message: %s\n", client.stub.id, &&client.stub.message[0]);

        [[ 
          TABLE = load (@client.stub.message)() 
          CLIENT.remote.args = TABLE.args or {}
        ]]

        evt = [] .. [[ TABLE.evt ]] .. [{'\0'}];
        if call Has_Mapping (&&evt[0], &evt_dev_role, false) then
          call Get_Mapping_Indices (&&evt[0], &evt_dev_role, &mapping);
          var ssize len = $mapping;
          var ssize i;
          loop i in [0 -> len[ do
            $mapped = 0;

            var int index = mapping[i];
            mapped = [] .. [[ CLIENT.mapping.events[@index ][3] .. '\0']];
            spawn Handle_Mapping (&&evt[0], &evt_dev_role, &&mapped[0]) in mapping_pool;
          end
        end
      end
    with
      /* SCENE */

      /* KEY */
      var uint obj;
      var _char_ptr_ext key;
      var bool press;
      var[] byte tmp;
      var[] byte buffer;
      every (obj, key, press) in mars_scene_key do

        var[] byte key_buff = [] .. (_PTR(key) as _char&&);
        [[
          luabuff = '{' ..
                    'device=' .. tostring(@client.stub.id)   .. ',' ..
                    'object=' .. tostring(@obj)              .. ',' ..
                    'evt="'   .. EVT_KEY                     .. '",' ..
                    "key='"   .. tostring(@key_buff)         .. "'," ..
                    'press='  .. tostring(@press)            ..
                    '}'
        ]]
        buffer = [] .. [[ luabuff ]];

        spawn Client_Send_Message (&client.stub, &buffer) in send_message_pool;
      end
    with
      /* CLICK */
      var uint obj;
      var int x;
      var int y;
      var int button;
      var bool press;
      var[] byte tmp;
      var[] byte buffer;
      every (obj, x, y, button, press) in mars_scene_mouse_clicked do
        [[
          luabuff = '{' ..
                    'device=' .. tostring(@client.stub.id)   .. ',' ..
                    'object=' .. tostring(@obj)              .. ',' ..
                    'evt="'   .. EVT_SCENE_CLICK             .. '",' ..
                    'x='      .. tostring(@x)                .. ',' ..
                    'y='      .. tostring(@y)                .. ',' ..
                    'button=' .. tostring(@button)           .. ',' ..
                    'press='  .. tostring(@press)            ..
                    '}'
        ]]
        buffer = [] .. [[ luabuff ]];

        spawn Client_Send_Message (&client.stub, &buffer) in send_message_pool;
      end

    with
      /* PLAYER */
      var uint obj;
      var int x;
      var int y;
      var int button;
      var bool press;
      var[] byte tmp;
      var[] byte buffer;
      every (obj, x, y, button, press) in mars_player_mouse_clicked do
        [[
          luabuff = '{' ..
                    'device=' .. tostring(@client.stub.id)   .. ',' ..
                    'object=' .. tostring(@obj)              .. ',' ..
                    'evt="'   .. EVT_PLAYER_CLICK            .. '",' ..
                    'x='      .. tostring(@x)                .. ',' ..
                    'y='      .. tostring(@y)                .. ',' ..
                    'button=' .. tostring(@button)           .. ',' ..
                    'press='  .. tostring(@press)            ..
                    '}'
        ]]
        buffer = [] .. [[ luabuff ]];
        spawn Client_Send_Message (&client.stub, &buffer) in send_message_pool;
      end
    with
      input (_char&&, _u_args) IN;
      var _char&& type;
      var _u_args args;
      var[] byte role;
      var[] byte buffer;
      every (type, args) in IN do
        role = [] .. [[ CLIENT.role.name ]];
__OUTPUT_HANDLE__
      end
    end
  end
with
  await mirror_ok;
  par/and do
    #include SRC
  with
    var[] byte role_name = [] .. "";
    var Exception.Lua? e;
    catch e do
      var ssize len = [[ CLIENT.role.name:len() ]];
      _alloc_role_name(len + 1);

      var ssize i;
      loop i in [1->len] do
        var byte c = [[ string.byte(CLIENT.role.name:sub(@i, @i)) ]];
        _ROLE_NAME[i - 1] = c;
      end
      _ROLE_NAME [len] = {'\0'};
      _ROLE_INDEX = [[ CLIENT.role.index ]];
      _MIRROR_OK = 1;
    end
    if e? then
      _fprintf (_stderr, "[JOINED error]: %s\n", e!.message);
    end
  end
end

__COMPILED_EVTS__

escape 0;
