#include "media/media.ceu"
#include "mars/client/mars-client.ceu"

native/pre do
__OUTPUT_TYPES__
end

[[
__INTERFACES__
]]

native/pos do
  int MIRROR_OK = 0;
  char* SERVER_IP = NULL;

	tceu_callback_ret evt_cb (int cmd,
														tceu_callback_arg p1,
														tceu_callback_arg p2,
														const char* filename,
														u32 line)
	{
    static int flag = 0;
    tceu_callback_ret ret = { .is_handled = 0 };
    switch (cmd)
    {
      case CEU_CALLBACK_STEP:
      {
        if (flag == 0)
        {
          char *device = "";
          char c;

          while ((c = getopt (CEU_APP.argc, CEU_APP.argv, "d:s:")) != -1)
          {
            switch (c)
            {
              case 'd':
              {
                device = optarg;
                break;
              }
              case 's':
              {
                SERVER_IP = optarg;
                break;
              }
            }
          }

          if (SERVER_IP == NULL)
            SERVER_IP = "0.0.0.0";

          optind = 0;

          tceu_input_INIT p = {device};
          ceu_input (CEU_INPUT_INIT, &p);
          flag = 1;

          ret.is_handled = 1;
        }
        break;
      }
      case CEU_CALLBACK_OUTPUT:
      {
        char *type;
        u_args p;
__CALLBACK_OUTPUT_COND__
        tceu_input_IN input_p = {type, p};
        ceu_input (CEU_INPUT_IN, &input_p);

        ret.is_handled = 1;
        break;
      }
    }

    return ret;
  }

  tceu_callback cb = { &evt_cb, NULL };
end

native/plain
  _SERVER_IP,
  _u_args,
;

native/nohold
  _cb,
;

_ceu_callback_register (&&_cb);

input (_char&&) INIT;

code/await Init (none) -> none
do
  var _char&& device;
  device = await INIT;
  var Exception? e;
  catch e do
    _printf ("[client] device: %s\n", device);

    /* TODO: parse devices by comma */
    [[ table.insert (MARS.instance, @device) ]]
  end
  if e? then
    _fprintf (_stderr, "[INIT error:] %s\n", e!.message);
  end
end

await Init ();

/* internal */
event (none) mirror_ok;

code/await Emit_Input_Event (var&[] byte evt) -> none;
code/await Handle_Mapping (var _char&& evt, var&[] byte from,  var _char&& mapping) -> none;

par/or do
  var int min_peers = _;

  var Exception.Lua? e;
  catch e do
    [[
      CONFIG = {}
      min_peers = 1
      chunk = loadfile ('config.lua')
      if chunk then
        CONFIG = chunk ()

        min_peers = CONFIG.MIN_PEERS or min_peers
      end
    ]]
    min_peers = [[ min_peers ]];
  end
  if e? then
    _fprintf (_stderr, "[Load_Sync_Config error]: %s\n", e!.message);
  end

  var&? Client client = spawn Client (_SERVER_IP, 0);
  watching client do
    await client.stub.all_set_up;

    pool [] Client_Send_Message send_message_pool;
    par do
      var uint id;
      var usize peers;
      (id, peers) = await client.stub.joined;
      _printf ("joined\n");
      /* device_id is defined in mars-media.ceu */
      device_id = id;
    with
      watching mirror_ok do
        var uint new_peer;
        var usize peers;
        every (new_peer, peers) in client.stub.new_peer do
          if (peers >= min_peers) then
            emit mirror_ok;
          end
        end
      end
    with
      pool[] Emit_Input_Event input_event_pool;
      pool[] Handle_Mapping mapping_pool;
      var[] byte evt = _;
      var[] int mapped = _;
      var[] int mapping = _;
      every client.stub.incoming_message do
        [[
          print ('incoming_message')
          print ('[APP(' .. tostring(@client.stub.id) .. ')] Message: ' ..
                                  @client.stub.message)

          TABLE = load (@client.stub.message)()
          MARS.message.args = TABLE.args or {}
        ]]

        evt = [] .. [[ TABLE.evt .. '\0']];
        spawn Emit_Input_Event (&evt) in input_event_pool;
      end
    with
      input (_char&&, _u_args) IN;
      var _char&& evt;
      var _u_args args;
      var[] byte interface;
      var[] byte buffer;
      var bool toSend = false;
      every (evt, args) in IN do
        [[
          interface = nil
          if MARS.peer ~= nil then
            print (serialize(MARS.peer))
            interface = MARS.peer:getInterfaceOfEvent (@evt)
          end
          print (interface)
        ]]
        toSend = [[ not (interface == nil) ]];
        if toSend then
__OUTPUT_HANDLE__
        end
      end
    end
  end
  _printf ("client finished\n");
with
  await mirror_ok;
  #include SRC
end

__INPUTS__

escape 0;
