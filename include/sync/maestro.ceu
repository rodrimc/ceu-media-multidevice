#include "media/media.ceu"
#include "mars/client/mars-client.ceu"

native/pre do
__OUTPUT_TYPES__
end

[[
__INTERFACES__
]]

native/pos do
  ##include <getopt.h>
  int MIRROR_OK = 0;
  char* SERVER_IP = NULL;

  struct option long_options[] =
    {
      {"min-peers", required_argument, NULL, 'm'},
      {"interface", required_argument, NULL, 'i'},
      {"server",    required_argument, NULL, 's'},
      {0, 0, 0, 0}
    };

	tceu_callback_ret evt_cb (int cmd,
														tceu_callback_arg p1,
														tceu_callback_arg p2,
														const char* filename,
														u32 line)
	{
    static int flag = 0;
    tceu_callback_ret ret = { .is_handled = 0 };
    switch (cmd)
    {
      case CEU_CALLBACK_STEP:
      {
        if (flag == 0)
        {
          int option_index = 0;
          int c;

          char *interface = "";
          int min_peers = 1;

          opterr = 0; //prevents the printing of unrecognized command line arg

          while ((c = getopt_long_only (CEU_APP.argc, CEU_APP.argv,
              "m:i:s:", long_options, &option_index)) != -1)
          {
            switch (c)
            {
              case 'i':
              {
                interface = optarg;
                break;
              }
              case 's':
              {
                SERVER_IP = optarg;
                break;
              }
              case 'm':
              {
                min_peers = strtol (optarg, NULL, 10);
                break;
              }
            }
          }

          if (SERVER_IP == NULL)
            SERVER_IP = "0.0.0.0";

          optind = 0;

          tceu_input_INIT p = {interface, min_peers};
          ceu_input (CEU_INPUT_INIT, &p);
          flag = 1;

          ret.is_handled = 1;
        }
        break;
      }
      case CEU_CALLBACK_OUTPUT:
      {
        char *type;
        u_args p;
__CALLBACK_OUTPUT_COND__
        tceu_input_IN input_p = {type, p};
        ceu_input (CEU_INPUT_IN, &input_p);

        ret.is_handled = 1;
        break;
      }
    }

    return ret;
  }

  tceu_callback cb = { &evt_cb, NULL };
end

native/plain
  _SERVER_IP,
  _u_args,
;

native/nohold
  _cb,
;

_ceu_callback_register (&&_cb);

input (_char&&, int) INIT;

code/await Init (none) -> int
do
  var _char&& interface;
  var int min;
  (interface, min) = await INIT;

  var Exception? e;
  catch e do
    _printf ("[client] interface: %s\n", interface);

    /* TODO: parse interfaces by comma */
    [[ table.insert (MARS.instance, @interface) ]]
  end
  if e? then
    _fprintf (_stderr, "[INIT error:] %s\n", e!.message);
  end

  escape min;
end

/* internal */
event (none) mirror_ok;

code/await Emit_Input_Event (var&[] byte evt) -> none;
code/await Handle_Mapping (var _char&& evt, var&[] byte from,  var _char&& mapping) -> none;

par/or do
  var int min_peers = await Init ();
  _printf ("min-peers: %d\n", min_peers);

  var&? Client client = spawn Client (_SERVER_IP, 0);
  watching client do
    await client.stub.all_set_up;

    pool [] Client_Send_Message send_message_pool;
    par do
      var uint id;
      var usize peers;
      (id, peers) = await client.stub.accepted;
      _printf ("accepted\n");
    with
      watching mirror_ok do
        var uint new_peer;
        var usize peers;
        every (new_peer, peers) in client.stub.new_peer do
          if (peers >= min_peers) then
            client.stub.ok = true;
            emit mirror_ok;
          end
        end
      end
    with
      pool[] Emit_Input_Event input_event_pool;
      pool[] Handle_Mapping mapping_pool;
      var[] byte evt = _;
      var[] int mapped = _;
      var[] int mapping = _;
      every client.stub.incoming_message do
        [[
          print ('incoming_message')
          print ('[APP(' .. tostring(@client.stub.id) .. ')] Message: ' ..
                                  @client.stub.message)

          TABLE = load (@client.stub.message)()
          MARS.message.args = TABLE.args or {}
        ]]

        evt = [] .. [[ TABLE.evt .. '\0']];
        spawn Emit_Input_Event (&evt) in input_event_pool;
      end
    with
      input (_char&&, _u_args) IN;
      var _char&& evt;
      var _u_args args;
      var[] byte interface;
      var[] byte buffer;
      var bool toSend = false;
      every (evt, args) in IN do
        [[
          interface = nil
          if MARS.peer ~= nil then
            print (serialize(MARS.peer))
            interface = MARS.peer:getInterfaceOfEvent (@evt)
          end
          print (interface)
        ]]
        toSend = [[ not (interface == nil) ]];
        if toSend then
__OUTPUT_HANDLE__
        end
      end
    end
  end
  _printf ("client finished\n");
with
  await mirror_ok;
  #include SRC
end

__INPUTS__

escape 0;
