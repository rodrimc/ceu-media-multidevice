#ifndef _CEU_MULTIDEVICE
#define _CEU_MULTIDEVICE

#include "uv/uv.ceu"
#include "uv/tcp.ceu"
/* #include "synchronizer.ceu" */

#define LOCALHOST "0.0.0.0"
#define PORT 8888
#define BACKLOG 128
#define BUFF_SIZE 256

/* MESSAGE CODES */
#define JOIN 1
#define UPDATE_START_TIME 2
#define PAUSE 3
#define RESUME 4
#define CLICK 5

/* REPLY CODES */
#define OK 0
#define ERROR -1

native/pre do
  ##include <time.h>

  long long unsigned int now (void)
  {
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long unsigned int)ts.tv_sec * 1000000000L + ts.tv_nsec;
  }

end

native
  _now,
;

data Dummy with
  event (int, u64) notify_pause;
  event (int) notify_resume;
  event (int) notify_click;
  event (uint, u64) update_start_time;
end

data Pair with
  var& uint session;
  var& u64 start_time;
end

vector[] Pair pairs;

var Dummy dummy = val Dummy (_,_,_,_);
var int id_ref = 0;



code/tight
Join (var& int id, var& uint session, var& u64 start_time, vector&[] byte msg)
                                                                      => void
do
  var bool flag = false;

  loop i in [0 -> $outer.pairs[ do
    if outer.pairs[i].session == session then
      flag = true;
      start_time = outer.pairs[i].start_time;
    end
  end

  if not flag then
    var Pair p = val Pair (&session, &start_time);
    outer.pairs = outer.pairs .. [p];
  end

  /* code */
  msg = [] .. "return {code=" .. [[ tostring (@JOIN) ]];

  /* reply */
  msg = msg .. ",reply=" .. [[ tostring (@OK) ]];

  /* id */
  msg = msg .. ",id=" .. [[ tostring (@id) ]];

  /* start time */
  var u64 tmp2 = start_time;
  msg = msg .. ",start=" .. [[ tostring (@tmp2) ]];

  /* timestamp */
  var u64 msg_ts = _now();
  msg = msg .. ",timestamp=" .. [[ tostring (@msg_ts) ]];

  /* end */
  msg = msg .. "}\n";
end

code/tight
Update_Start_Time (var& int id, var& uint session, var& u64 start_time, 
      vector&[] byte msg) => void
do
  start_time = [[ tostring(TABLE.start) ]];
  _printf ("[server (%d)] new start time: %lu\n", id, start_time);

  emit outer.dummy.update_start_time (session, start_time);

  /* code */
  msg = [] .. "return {code=" .. [[ tostring (@UPDATE_START_TIME) ]];

  /* reply */
  msg = msg .. ",reply=" .. [[ tostring (@OK) ]];

  /* timestamp */
  var u64 msg_ts = _now();
  msg = msg .. ",timestamp=" .. [[ tostring (@msg_ts) ]];

  /* end */
  msg = msg .. "}\n";
end

code/tight
Pause (var& int id, var& uint session) => void
do
  var u64 pause_time = [[ tostring(TABLE.pause) ]];
  _printf ("[server (%d)] pause time: %lu\n", id, pause_time);

  emit outer.dummy.notify_pause (id, pause_time);
end

code/await UV_TCP_Server_Handler (var& _uv_tcp_t client) => int
do
  var uint session = 0;
  var int id = outer.id_ref;
  outer.id_ref = outer.id_ref + 1;
  var u64 start_time = 0;

  par do
    loop do
      vector[] byte msg;
      var int code_ = _;

      await UV_TCP_ReadLine(&client, &msg);

      var u64 msg_received_time = _now();
      _printf ("%s\n", &&msg[0]);
      [[ TABLE =  load (@msg)()]]

      var u64 ts = [[ TABLE.timestamp ]];

      var u64 delay_estimation = msg_received_time - ts ;

      code_ = [[ TABLE.code ]];

      var bool send_reply = true;
      if code_ == JOIN then
        call Join (&id, &session, &start_time, &msg);

      else/if code_ == UPDATE_START_TIME then
        call Update_Start_Time (&id, &session, &start_time, &msg);

      else/if code_ == PAUSE then
        call Pause (&id, &session);

        send_reply = false;
      else/if code_ == RESUME then
        emit outer.dummy.notify_resume (id);

        send_reply = false;
      else/if code_ == CLICK then
        emit outer.dummy.notify_click (id);

        send_reply = false;
      else
        _printf ("[connection] Unknown code\n");
      end

      if (send_reply) then
        _printf ("[server (%d)] reply: %s", id, &&msg[0]);
        await UV_TCP_Write(&client, &msg);
      end
    end
  with
    loop do
      var int i;
      var u64 time;
      (i, time) = await outer.dummy.notify_pause;

      _printf ("%d: dummy(%d).notify_pause\n", id, i);
      vector[] byte msg = [] .. "";

      /* code */
      msg = [] .. "return {code=" .. [[ tostring (@PAUSE) ]];

      /* from */
      msg = msg .. ",from=" .. [[ tostring (@i) ]];

      /* pause time*/
      msg = msg .. ",pause_time=" .. [[ tostring (@time) ]];

      /* timestamp */
      var u64 msg_ts = _now();
      msg = msg .. ",timestamp=" .. [[ tostring (@msg_ts) ]];

      /* end */
      msg = msg .. "}\n";

      _printf ("[server (%d)] send: %s", id, &&msg[0]);
      await UV_TCP_Write(&client, &msg);
    end
  with
    loop do
      var int i = -1;
      var int code_ = -1;
      par/or do
        i = await outer.dummy.notify_resume;
        _printf ("%d: dummy(%d).notify_resume\n", id, i);
        code_ = RESUME;
      with
        i = await outer.dummy.notify_click;
        _printf ("%d: dummy(%d).notify_click\n", id, i);
        code_ = CLICK;
      end

      vector[] byte msg = [] .. "";

      /* code */
      msg = [] .. "return {code=" .. [[ tostring (@code_) ]];

      /* from */
      msg = msg .. ",from=" .. [[ tostring (@i) ]];

      /* timestamp */
      var u64 msg_ts = _now();
      msg = msg .. ",timestamp=" .. [[ tostring (@msg_ts) ]];

      /* end */
      msg = msg .. "}\n";

      _printf ("[server (%d)] send: %s", id, &&msg[0]);
      await UV_TCP_Write(&client, &msg);
    end
  with
    var uint session_;
    var u64 time_;
    every (session_, time_) in outer.dummy.update_start_time do
      if (session_ == session) then
        start_time = time_;
      end
    end
  end
end

/* We must include tcp-server after we've defined UV_TCP_Server_Handler */
#include "uv/tcp-server.ceu"

data IMediaClient with
  var& _uv_tcp_t tcp;
  event (void) joined;
  event (void) send_click;
  event (int) clicked;
end

code/await MediaClient (var _char&& ip, var int port, var int session)
                          => (var& IMediaClient client, var& int id)
                            => void
do
  var int id_ref_ = -1;
  id = &id_ref_; 

  event& void connected;
  var& _uv_tcp_t tcp_;

  watching UV_TCP_Connect(ip, port) => (tcp_, connected)
  do
    var IMediaClient ref_ = val IMediaClient (&tcp_, _, _, _); 
    client = &ref_; 

    await connected;

    vector[] byte msg = [] .. "return {code=" .. [[ tostring (@JOIN) ]];
    msg = msg .. ",session=" .. [[ tostring (@session) ]];

    var u64 msg_ts = _now();
    msg = msg .. ",timestamp=" .. [[ tostring (@msg_ts) ]] .. "}\n";

    /* send JOIN message */
    await UV_TCP_Write(&ref_.tcp, &msg);
    par do
      loop do
        vector [BUFF_SIZE] byte buff;
        var int code_ = _;

        /* await message */
        await UV_TCP_ReadLine(&ref_.tcp, &buff);
        _printf ("[MediaClient (%d)] read: %s", id_ref_, &&buff[0]);

        /* parse message */
        [[ TABLE =  load (@buff)()]]
        code_ = [[ TABLE.code ]];

        if code_ == JOIN then
          var int reply;
          reply = [[ TABLE.reply ]];

          if reply != OK then
            _printf ("[MediaClient (%d)] I've received an error\n", id_ref_);
            break;
          end
          id_ref_ = [[ TABLE.id ]];
          _printf ("[MediaClient (%d)] My id: %d\n", id_ref_, id_ref_);
          emit ref_.joined;
        else/if code_ == CLICK then
          var int from = [[ TABLE.from ]];
          _printf ("[MediaClient (%d)] %d has clicked\n", id_ref_, from);
          emit ref_.clicked (from); 
        end
      end
    with
      loop do
        await ref_.send_click;
        
        msg =  [] ..  "return {code=" .. [[ tostring (@CLICK) ]];
        msg = msg .. ",session=" .. [[ tostring (@session) ]];
        msg = msg .. ",id=" .. [[ tostring (@id_ref_) ]];

        msg_ts = _now();
        msg = msg .. ",timestamp=" .. [[ tostring (@msg_ts) ]].. "}\n";

        /* send CLICK message */
        await UV_TCP_Write(&ref_.tcp, &msg);
      end
    end
  end
end

#endif
