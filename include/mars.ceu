#ifndef _CEU_MULTIDEVICE
#define _CEU_MULTIDEVICE

#include "uv/uv.ceu"
#include "uv/tcp.ceu"

#define LOCALHOST "0.0.0.0"
#define PORT 8888
#define BACKLOG 128

/* MESSAGE CODES */
#define JOIN             0
#define NEW_PEER         1
#define REGULAR_SEND     2
#define CONCURRENT_SEND  3
#define ORDERED_SEND     4
/* more? */

native/pre do
  ##include <time.h>

  long long unsigned int now (void)
  {
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long unsigned int)ts.tv_sec * 1000000000L + ts.tv_nsec;
  }
end

native
  _now,
;
[[
   function serialize (o)
     local result = '{'
     for k,v in pairs(o) do
       result = result ..  k .. '='
       if type (v) == 'string' then
         result = result .. "'" .. v .. "',"
       else
         result = result .. v .. ','
       end
     end
     result = result .. '}'
     return result
   end
]]

event (int) send_broadcast_join;
event (int) send_broadcast_message;
vector []byte cur_payload;

var int id_ref = 1;
var uint peers_count = 0;

code/await Send_Broadcast_Join (var& _uv_tcp_t client, var int id) -> void
do
  vector[] byte buffer = [] .. "";

  buffer = [] .. "return {type=" .. [[ tostring(@NEW_PEER) ]];
  buffer = buffer .. ",new_peer=" .. [[ tostring (@id) ]];
  buffer = buffer .. ",peers=" .. [[ tostring (@outer.peers_count) ]];
  var u64 ts = _now ();
  buffer = buffer .. ",timestamp=" .. [[ tostring (@ts) ]];
  buffer = buffer .. "}\n";

  await UV_TCP_Write (&client, &buffer);
end

code/await Send_Broadcast_Message (var& _uv_tcp_t client, var uint from,
                                   vector& []byte payload) -> void
do
  vector[] byte buffer = [] .. "";

  buffer = [] .. "return {from=" .. [[ tostring (@from) ]];
  buffer = buffer .. ",type=" .. [[ tostring (@REGULAR_SEND) ]];
  buffer = buffer .. ",payload=" .. payload;
  var u64 ts = _now ();
  buffer = buffer .. ",timestamp=" .. [[ tostring (@ts) ]];
  buffer = buffer .. "}\n";

  _printf ("[server] sent: %s", &&buffer[0]);
  await UV_TCP_Write (&client, &buffer);
end

code/await UV_TCP_Server_Handler (var& _uv_tcp_t client) -> int
do
  var uint session = _;
  var int id = outer.id_ref;
  outer.id_ref = outer.id_ref + 1;
  var u64 start_time = 0;

  outer.peers_count = outer.peers_count + 1;
  do finalize with
    outer.peers_count = outer.peers_count - 1;
  end

  par do
    loop do
      vector[] byte buffer;
      await UV_TCP_ReadLine(&client, &buffer);
      _printf ("[server] received: %s\n", &&buffer[0]);

      var int type = _;

      [[ TABLE =  load (@buffer)()]]
      type = [[ TABLE.type ]];

      if type == JOIN then
        buffer = [] .. "return {";
        buffer = buffer .. "type=" .. [[ tostring (@JOIN) ]];
        buffer = buffer .. ",id=" .. [[ tostring(@id) ]];
        buffer = buffer .. ",peers=" .. [[ tostring(@outer.peers_count) ]];
        buffer = buffer .. "}\n";

        await UV_TCP_Write (&client, &buffer);
        _printf ("[server] sent: %s\n", &&buffer[0]);

        emit outer.send_broadcast_join (id);

      else/if type == REGULAR_SEND then
        var int from = [[ TABLE.from ]];
        vector[] byte payload = [] .. [[ serialize(TABLE.payload) ]];

        outer.cur_payload = [] .. payload;
        emit outer.send_broadcast_message (from);
      end
    end
  with
    var int new_id;
    every new_id in outer.send_broadcast_join do
      spawn Send_Broadcast_Join (&client, new_id);
    end
  with
    var int from;
    every from in outer.send_broadcast_message do
      spawn Send_Broadcast_Message (&client, from, &outer.cur_payload);
    end
  end

end

/* We must include tcp-server after we've defined UV_TCP_Server_Handler */
#include "uv/tcp-server.ceu"

data IPeer with
  var& _uv_tcp_t tcp;
  var uint id;
  vector&[] byte rbuffer;
  vector&[] byte wbuffer;
  vector&[] byte message;
  event (void) joined;
  event (void) incoming_message;
  event (void) send;
  event (void) sent;
end

code/await Peer (var _char&& ip, var int port, var int session)
                          -> (var& IPeer peer)
                            -> void
do
  event& (void) connected;
  var& _uv_tcp_t tcp_;

  watching UV_TCP_Connect(ip, port) -> (&tcp_, &connected)
  do
    vector []byte rbuffer;
    vector []byte wbuffer;
    vector []byte message;
    var IPeer ref_ = val IPeer (&tcp_, 0, &rbuffer, &wbuffer, &message, _, _, _, _);
    peer = &ref_;

    await connected;

    par do
      wbuffer = [] .. "return {";
      wbuffer = wbuffer .. "type=" .. [[ tostring (@JOIN) ]];
      wbuffer = wbuffer .. "}\n";

      /* send JOIN message */
      await UV_TCP_Write(&ref_.tcp, &wbuffer);
    with
      loop do
        await ref_.send;
        vector[] byte payload = [] .. ref_.wbuffer;
        ref_.wbuffer = [] .. "return{payload=" .. payload;
        ref_.wbuffer = ref_.wbuffer .. ",from=" .. [[ tostring (@ref_.id) ]];
        ref_.wbuffer = ref_.wbuffer .. ",type=" .. [[ tostring (@REGULAR_SEND) ]];
        var u64 ts = _now();
        ref_.wbuffer = ref_.wbuffer .. ",timestamp=" .. [[ tostring(@ts) ]];
        ref_.wbuffer = ref_.wbuffer .. "}\n";

        _printf ("[Peer (%d)] sending: %s\n", ref_.id, &&ref_.wbuffer[0]);
        await UV_TCP_Write(&ref_.tcp, &ref_.wbuffer);
        emit ref_.sent;
      end
    with
      /* await message */
      loop do
        event& usize ok;
        watching UV_Stream_Read(&ref_.tcp, &ref_.rbuffer) -> (&ok) do
          await ok;
          var usize i;
          loop i in [0 -> $ref_.rbuffer[ do
            if ref_.rbuffer[i] != { '\n' } then
              ref_.message = ref_.message .. [ref_.rbuffer[i]];
            else
              var int type = _;

              /* parse message */
              [[ TABLE =  load (@message)()]]

              type = [[ TABLE.type ]];

              if type == JOIN then
                ref_.id = [[ TABLE.id ]];
                _printf ("[Peer (%d)] My id: %d\n", ref_.id, ref_.id);
                emit ref_.joined;

              else/if type == REGULAR_SEND then 
                ref_.message = [] .. "return " .. [[ serialize (TABLE.payload) ]]; 
                _printf ("[Peer (%d)] Incoming message: %s\n", ref_.id,
                                                  &&ref_.message[0]);
                emit ref_.incoming_message;

              else
                _printf ("[Peer (%d)] Incoming message: %s\n", ref_.id,
                                                  &&ref_.message[0]);
                emit ref_.incoming_message;
              end

              ref_.message = [] .. "";
            end
          end
        end
      end
    end
  end
end
#endif
