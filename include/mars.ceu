#ifndef _CEU_MULTIDEVICE
#define _CEU_MULTIDEVICE

#include "uv/uv.ceu"
#include "uv/tcp.ceu"

#define LOCALHOST "0.0.0.0"
#define PORT 8888
#define BACKLOG 128

/* MESSAGE CODES */
#define JOIN             0 
#define NEW_PEER         1 
#define REGULAR_SEND     2 
#define CONCURRENT_SEND  3 
#define ORDERED_SEND     4 
/* more? */

/* REPLY CODES */
#define OK 0
#define ERROR -1

native/pre do
  ##include <time.h>

  typedef char* char_ptr;

  long long unsigned int now (void)
  {
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long unsigned int)ts.tv_sec * 1000000000L + ts.tv_nsec;
  }
end

native
  _now,
;

native/plain
  _char_ptr,
;

data Message with
  var uint from;
  var u64 offset; 
  var u64 ts; 
end

event (int) send_multicast_join;
event (uint) send_multicast;

event (int, u64) notify_pause;
event (int) notify_resume;
event (int) notify_click;
event (uint, u64) update_start_time;

var int id_ref = 0;
var uint peers_count = 0; 

var Message current_message = _;
vector[] byte current_payload; 

code/await Send_Broadcast_Join (var& _uv_tcp_t client, var int id) -> void 
do
  vector[] byte msg = [] .. "";

  msg = [] .. "return {type=" .. [[ tostring(@NEW_PEER) ]];
  msg = msg .. ",peer=" .. [[ tostring (@id) ]];
  msg = msg .. "}\n";

  await UV_TCP_Write (&client, &msg);

end

code/await Send_Broadcast_Message (var& _uv_tcp_t client) -> void 
do
  vector[] byte msg = [] .. "";

  msg = [] .. "return {from=" .. [[ tostring (@outer.current_message.from) ]];
  msg = msg .. ",payload=" .. outer.current_payload;
  msg = msg .. ",offset=" .. [[ tostring (@outer.current_message.offset) ]];
  msg = msg .. ",timestamp=" .. [[ tostring (@outer.current_message.ts) ]];
  msg = msg .. "}\n";

  await UV_TCP_Write (&client, &msg);
end

code/await UV_TCP_Server_Handler (var& _uv_tcp_t client) -> int
do
  var uint session = _;
  var int id = outer.id_ref;
  outer.id_ref = outer.id_ref + 1;
  var u64 start_time = 0;

  outer.peers_count = outer.peers_count + 1;

  par do
    loop do
      vector[] byte msg; 
      await UV_TCP_ReadLine(&client, &msg);
      _printf ("[server] received: %s\n", &&msg[0]);

      var int type = _;

      [[ TABLE =  load (@msg)()]]
      type = [[ TABLE.type ]];

      if type == JOIN then
        msg = [] .. "return {";
        msg = msg .. "type=" .. [[ tostring (@JOIN) ]];
        msg = msg .. ",id=" .. [[ tostring(@id) ]];
        msg = msg .. ",peers=" .. [[ tostring(@outer.peers_count) ]];
        msg = msg .. "}\n";

        await UV_TCP_Write (&client, &msg);
        _printf ("[server] sent: %s\n", &&msg[0]);

        emit outer.send_multicast_join (id);

      else/if type == REGULAR_SEND then
        var int from = [[ TABLE.from ]];
        vector[] byte payload = [] .. [[ TABLE.payload ]];
        var u64 offset = [[ TABLE.offset ]];
        var u64 ts = [[ TABLE.ts ]];
        outer.current_message = val Message (from, offset, ts); 
        outer.current_payload = [] .. payload;

        spawn Send_Broadcast_Message (&client);
      end
    end
  with
    var int new_id;
    every new_id in outer.send_multicast_join do
      if new_id != id then
        spawn Send_Broadcast_Join (&client, new_id);
      end
    end
  end
end

/* We must include tcp-server after we've defined UV_TCP_Server_Handler */
#include "uv/tcp-server.ceu"

data IPeer with
  var& _uv_tcp_t tcp;
  var int id;
  event (void) joined;
  event (_char_ptr) message; 
end

code/await Peer (var _char&& ip, var int port, var int session)
                          -> (var& IPeer peer)
                            -> void
do
  event& (void) connected;
  var& _uv_tcp_t tcp_;

  watching UV_TCP_Connect(ip, port) -> (&tcp_, &connected)
  do
    var IPeer ref_ = val IPeer (&tcp_, -1, _, _); 
    peer = &ref_; 

    await connected;

    vector []byte msg;
    msg = [] .. "return {";
    msg = msg .. "type=" .. [[ tostring (@JOIN) ]];
    msg = msg .. "}\n";

    /* send JOIN message */
    await UV_TCP_Write(&ref_.tcp, &msg);
    _printf ("[peer] sent: %s\n", &&msg[0]);

    par do
      loop do
        var int type = _;

        /* await message */
        await UV_TCP_ReadLine(&ref_.tcp, &msg);
        _printf ("[Peer (%d)] read: %s", ref_.id, &&msg[0]);

        /* parse message */
        [[ TABLE =  load (@msg)()]]
        type = [[ TABLE.code ]];

        if type == JOIN then

          ref_.id = [[ TABLE.id ]];
          _printf ("[Peer (%d)] My id: %d\n", ref_.id, ref_.id);
          emit ref_.joined;
        else
          /* var _char_ptr ptr = &&msg[0]; */
        end
      end
    with
    end
  end
end

#if 0
        else/if type == CLICK then
          var int from = [[ TABLE.from ]];
          _printf ("[MediaClient (%d)] %d has clicked\n", id_ref_, from);
          emit ref_.clicked (from); 
        end
      end
    with
      loop do
        await ref_.send_click;
        
        msg =  [] ..  "return {code=" .. [[ tostring (@CLICK) ]];
        msg = msg .. ",session=" .. [[ tostring (@session) ]];
        msg = msg .. ",id=" .. [[ tostring (@id_ref_) ]];

        msg_ts = _now();
        msg = msg .. ",timestamp=" .. [[ tostring (@msg_ts) ]].. "}\n";

        /* send CLICK message */
        await UV_TCP_Write(&ref_.tcp, &msg);
      end
    end
  end
end
#endif

#endif
