#ifndef _CEU_MARS_SERVER
#define _CEU_MARS_SERVER

/* Server Lua global */
[[
  SERVER =
    {
      mapping = nil,
      interface = nil,
      roles = {}
    }

  function interface (T)
    SERVER.interface = type(T) == 'table' and T or nil
  end

  function mapping (M)
    SERVER.mapping = type(M) == 'table' and M or nil
  end

  function get_mapping (evt)
    local map = {}
    if type(SERVER.mapping) == 'table' then
      for _,v in pairs (SERVER.mapping) do
        print (v[1])
        if v[1] == evt then
          table.insert(map, v)
        end
      end
    end
    return map
  end
]]

#include "mars/util/mars-defs.ceu"

native/pos do
  ##include <unistd.h>

	tceu_callback_ret evt_cb (int cmd,
														tceu_callback_arg p1,
														tceu_callback_arg p2,
														const char* filename,
														u32 line)
	{
    static int flag = 0;
    tceu_callback_ret ret = { .is_handled=0 };
    if (flag == 0 && cmd == CEU_CALLBACK_STEP)
    {
      char *interface_file = NULL;
      char *mapping_file = NULL;
      char c;

      while ((c = getopt (CEU_APP.argc, CEU_APP.argv, "i:m:")) != -1)
      {
        switch (c)
        {
          case 'i':
          {
            interface_file = optarg;
            break;
          }
          case 'm':
          {
            mapping_file = optarg;
            break;
          }
        }
      }

      tceu_input_INIT p = {interface_file, mapping_file};

      ceu_input (CEU_INPUT_INIT, &p);

      flag = 1;
      ret.is_handled = 1;
    }
    return ret;
  }

  tceu_callback cb = { &evt_cb, NULL };
end

native/nohold
  _ceu_callback_register,
  _cb,
;

_ceu_callback_register (&&_cb);

input (_char&&, _char&&) INIT;

var _char&& mapping;
var _char&& interface;
(interface, mapping) = await INIT;

var Exception? e;
catch e do
  _printf ("[server] interface file: %s\n", interface);
  if interface != null then
    [[
      dofile (@interface)
    ]]
  end
end
if e? then
  _fprintf (_stderr, "[INTERFACES error:] %s\n", e!.message);
  escape 0;
end

catch e do
  _printf ("[server] mapping file: %s\n", mapping);
  if mapping != null then
    [[
      dofile (@mapping)
    ]]
  end
end
if e? then
  _fprintf (_stderr, "[MAPPING error:] %s\n", e!.message);
end

data UV_TCP_Server_Data with
  var bool isReading;
end

/*** SERVER SIDE ***/
event (uint) send_broadcast_join;
event (uint, int) send_broadcast_message;
event (uint) send_tick_message;

var[] byte mapped_evt = _;
var[] byte mapped_dest = _;
var[] byte cur_payload;
var[] byte cur_role;

var uint id_ref = 1;
var usize peers_count = 0;

#define FREQ 50
spawn do
  every (FREQ)ms do
    emit send_tick_message(FREQ);
  end
end

code/await Send_Not_Joined_Reply (var uint handle_id,
                                  var& UV_Stream stream) -> none
do
  var Exception.Lua? e;
  catch e do
    [[
      luabuff = 'type='   .. tostring(@S_NOT_JOINED)
    ]]
    var[] byte buff = [] .. [[ luabuff ]];
    await Send (handle_id, &stream, &buff);
  end
  if e? then
    _fprintf (_stderr, "[Send_Not_Joined_Reply error]: %s\n", e!.message);
  end
end

code/await Send_Join_Reply (var uint handle_id,
                            var& UV_Stream stream,
                            var uint id,
                            var int status,
                            var int index,
                            var& []byte outputs) -> none
do
  var Exception.Lua? e;
  catch e do
    [[
      luabuff = 'type='     .. tostring(@S_JOINED)          .. ',' ..
                'id='       .. tostring(@id)                .. ',' ..
                'peers='    .. tostring(@outer.peers_count) .. ',' ..
                'status='   .. tostring(@status)            .. ',' ..
                'outputs="' .. tostring(@outputs)           .. '",' ..
                'index='    .. tostring(@index)
      print (luabuff)
    ]]
    var[] byte buff = [] .. [[ luabuff ]];
    await Send (handle_id, &stream, &buff);
  end
  if e? then
    _fprintf (_stderr, "[Send_Join_Reply error]: %s\n", e!.message);
  end
end

code/await Send_Broadcast_Join (var uint handle_id,
                                var& UV_Stream stream,
                                var uint id) -> none
do
  var Exception.Lua? e;
  catch e do
    var u64 ts = _now ();
    [[
      luabuff = 'type='      .. tostring(@S_NEW_PEER)        .. ',' ..
                'new_peer='  .. tostring(@id)                .. ',' ..
                'peers='     .. tostring(@outer.peers_count)
    ]]
    var[] byte buff = [] .. [[ luabuff ]];
    await Send (handle_id, &stream, &buff);
  end
  if e? then
    _fprintf (_stderr, "[Send_Broadcast_Join error]: %s\n", e!.message);
  end
end

code/await Send_Broadcast_Message (var uint handle_id,
                                   var& UV_Stream stream,
                                   var uint from,
                                   var& []byte role,
                                   var int index,
                                   var& []byte payload) -> none
do
  var Exception.Lua? e;
  catch e do
    var u64 ts = _now ();
    [[
      luabuff = 'type='      .. tostring(@S_BROADCAST)       .. ',' ..
                'from='      .. tostring(@from)              .. ',' ..
                'payload='   .. tostring(@payload)           .. ',' ..
                'role="'     .. tostring(@role)              .. '",' ..
                'index='     .. tostring(@index)             .. ',' ..
                'peers='     .. tostring(@outer.peers_count)
    ]]
    var[] byte buff = [] .. [[ luabuff ]];
    await Send (handle_id, &stream, &buff);
  end
  if e? then
    _fprintf (_stderr, "[Send_Broadcast_Message error]: %s\n", e!.message);
  end
end

code/await Send_Tick_Message (var uint handle_id,
                              var& UV_Stream stream,
                              var uint freq) -> none
do
  var Exception.Lua? e;
  catch e do
    var[] byte buff = _;
      [[
        luabuff = 'type=' .. tostring(@S_TICK)               .. ',' ..
                  'freq=' .. tostring(@freq)
      ]]

      buff = [] .. [[ luabuff ]];
    await Send (handle_id, &stream, &buff);
  end

  if e? then
      _fprintf(_stderr, "[Send_Tick_Message error]: %s\n", e!.message);
  end
end

code/await Reading_Handler (var& UV_Stream stream) -> NEVER
do
  loop do
    var[] byte buffer;
    var bool success = await Receive (&stream, &buffer);

    if not success then
      continue;
    end
    _printf ("received: %s\n", &&buffer[0]);

    var Exception.Lua? e;
    catch e do
      [[
        TABLE = load ('return{' .. @buffer .. '}')()
      ]]
      var int type = [[ TABLE.type ]];

      if  type == P_REGULAR_SEND then
        var uint from = [[ TABLE.from ]];
        var int index = [[ TABLE.index or -1 ]];

        outer.cur_role = [] .. [[ TABLE.role ]];

        [[ print (serialize(TABLE.payload)) ]]
        [[ m = get_mapping (TABLE.payload.evt) ]]

        var ssize len = [[ #m ]];
        var ssize i;
        loop i in [1 -> len] do
          var bool flag = [[ m[@i][2] == TABLE.role ]];
          if flag then
            outer.mapped_evt = [] .. [[ m[@i][3] .. '\0']];
            outer.mapped_dest = [] .. [[ (m[@i][4] or '') .. '\0' ]];

            [[
              --TODO: apply function to args
              TABLE.payload.evt = m[@i][3]
            ]]

            outer.cur_payload = [] .. [[ serialize (TABLE.payload) ]];

            emit outer.send_broadcast_message (from, index);
          end
        end

      end
    end
    if e? then
      _printf ("[error]: %s\n", e!.message);
    end
  end
end

code/await Writing_Handler (var& UV_Stream stream) -> NEVER
                            throws Exception.Uv
do
  var uint handle_id = outer.id_ref;
  outer.id_ref = outer.id_ref + 1;

  outer.peers_count = outer.peers_count + 1;
  do finalize with
    outer.peers_count = outer.peers_count - 1;
  end

  pool[] Send_Not_Joined_Reply  pool_not_joined_reply;
  pool[] Send_Join_Reply        pool_join_reply;
  pool[] Send_Broadcast_Join    pool_broadcast_join;
  pool[] Send_Broadcast_Message pool_broadcast_message;
  pool[] Send_Tick_Message      pool_tick_message;

  var[] byte myrole = [] .. "";
  var[] byte outputs = [] .. "";
  var int myindex = _;
  var int status = _;

  event (none) accepted;

  par do
    loop do
      var[] byte buff;
      var bool success = await Receive (&stream, &buff);

      var Exception.Lua? e;
      catch e do
        [[ MESSAGE = load ('return {' .. @buff .. '}')() ]]
        var int type = [[ MESSAGE.type ]];

        if (type == P_JOIN) then
          [[
            role = nil
            status = NOT_ACCEPTED
            outputs = ''
            if MESSAGE.role and SERVER.interface and
               type(SERVER.interface) == 'table' then
              role = MESSAGE.role

              if SERVER.interface[role] ~= nil then
                status = ACCEPTED

                for k,v in pairs (SERVER.interface[role].outputs) do
                  for k1,v1 in pairs (v) do
                    outputs = outputs .. k1 .. ','
                  end
                end

                if outputs ~= '' then
                  outputs = outputs:sub (1, -2)
                end
                print (outputs)

                if SERVER.roles[role] == nil then
                  SERVER.roles[role] = 1
                else
                  SERVER.roles[role] = SERVER.roles[role] + 1
                end

                index = SERVER.roles[role]
              end
            else
              role = ''
              index = 0
            end
          ]]
          status = [[ status ]];

          if status == ACCEPTED then
            myrole = [] .. [[ role .. '\0' ]];
            myindex = [[ index ]];
            outputs = [] .. [[ outputs ]];
            emit accepted ();
            spawn Send_Join_Reply (handle_id, &stream, handle_id, status,
                                   myindex, &outputs) in pool_join_reply;
            emit outer.send_broadcast_join (handle_id);
          else
            spawn Send_Not_Joined_Reply (handle_id, &stream)
                                                      in pool_not_joined_reply;
          end


          break;
        end
      end
      if e? then
        _fprintf (_stderr, "[error]: %s\n", e!.message);
      end
    end
  with
    await accepted;
    par do
      var uint freq;
      every freq in outer.send_tick_message do
        spawn Send_Tick_Message (handle_id, &stream, 50) in pool_tick_message;
      end
    with
      var uint new_id;
      every new_id in outer.send_broadcast_join do
        spawn Send_Broadcast_Join (handle_id, &stream, new_id)
                                                        in pool_broadcast_join;
      end
    with
      var uint from;
      var int index;
      every (from, index) in outer.send_broadcast_message do
        if _strcmp (&&myrole[0], &&outer.mapped_dest[0]) == 0 then
          _printf ("payload: %s\n", &&outer.cur_payload[0]);

          spawn Send_Broadcast_Message (handle_id, &stream, from, &outer.cur_role,
                                        index, &outer.cur_payload)
                                        in pool_broadcast_message;
        end
      end
    end
  end
end

/* Handler for each client */
code/await UV_TCP_Server_Handler (var& UV_Stream stream,
                                  var& UV_TCP_Server_Data shared) -> int
do
  var Exception.Uv? e;
  catch e do
    if (shared.isReading) then
      await Reading_Handler (&stream);
    else
      await Writing_Handler (&stream);
    end
  end

  if e? then
    _fprintf(_stderr, "[error]: %s\n", e!.message);
  end
end

/* We must include tcp-server after we've defined UV_TCP_Server_Handler */
#include "uv/tcp-server.ceu"

#endif
