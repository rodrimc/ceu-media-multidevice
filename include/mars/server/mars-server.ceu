#ifndef _CEU_MARS_SERVER
#define _CEU_MARS_SERVER

/* Server Lua global */
[[
  dofile ('mars-server.lua')

  __peers = require 'peers'

  SERVER =
    {
      peers = {},
      devices = {},
      mapping = nil,
      interface = nil,
      handler_interfaces = {},
    }
]]

#include "mars/util/mars-defs.ceu"

native/pos do
  ##include <assert.h>
  ##include <unistd.h>
  ##include <sys/socket.h>
  ##include "mars/server/native-pre-server.c"

	##include <netdb.h>

  char* mars_get_peer_net_info (uv_stream_t *stream, int* port)
  {
    struct sockaddr_storage addr;
    char *str = NULL;
    int len;
    if (uv_tcp_getpeername ((uv_tcp_t*) stream, (struct sockaddr*) &addr, &len) == 0)
    {
      int ret;
      switch (addr.ss_family)
      {
        case AF_INET:
        {
          char ip_str [INET_ADDRSTRLEN];
          struct sockaddr_in* src = (struct sockaddr_in*) &addr;
          ret = uv_inet_ntop(AF_INET, &src->sin_addr, ip_str, sizeof(ip_str));

          if (ret)
            fprintf(stderr, "getsockname fail\n");

          str = strdup(ip_str);
          *port = ntohs(src->sin_port);
          break;
        }
        case AF_INET6:
        {
          char ip_str[INET6_ADDRSTRLEN];
          struct sockaddr_in6* src = (struct sockaddr_in6*) &addr;
          ret = uv_inet_ntop(AF_INET6, &src->sin6_addr, ip_str, sizeof(ip_str));

          if (ret)
            fprintf(stderr, "getsockname fail\n");

          str = strdup(ip_str);
          *port = ntohs(src->sin6_port);
          break;
        }
      }
    }
    assert (str);
    return str;
  }
end

native/nohold
  _ceu_callback_register,
  _mars_get_peer_net_info,
  _cb,
;

_ceu_callback_register (&&_cb);

input (_char&&, _char&&) INIT;

code/await Init (none) -> int
do
  var _char&& mapping;
  var _char&& interface;
  (interface, mapping) = await INIT;

  var Exception? e;
  catch e do
    _printf ("[server] interface file: %s\n", interface);
    if interface != null then
      [[
        dofile (@interface)
      ]]
    end
  end
  if e? then
    _fprintf (_stderr, "[INTERFACES error:] %s\n", e!.message);
    escape -1;
  end

  catch e do
    _printf ("[server] mapping file: %s\n", mapping);
    if mapping != null then
      [[
        dofile (@mapping)
      ]]
    end
  end
  if e? then
    _fprintf (_stderr, "[MAPPING error:] %s\n", e!.message);
  end

  escape 0;
end

var int ret = await Init();
if ret != 0 then
  escape ret;
end

data UV_TCP_Server_Data with
  var bool isReading;
end

/*** SERVER SIDE ***/
event (uint) send_broadcast_join;
event (uint, int) send_broadcast_message;
event (uint) send_tick_message;

var[] byte mapped_evt = _;
var[] byte mapped_dest = _;
var[] byte cur_payload;
var[] byte cur_interface;

var uint id_ref = 1;
var usize peers_count = 0;

#include "messages-server.ceu"

code/await Reading_Handler (var& UV_Stream stream,
                            var&[] byte ip,
                            var int port) -> NEVER
do
  loop do
    var[] byte buffer;
    var bool success = await Receive (&stream, &buffer);

    if not success then
      continue;
    end
    _printf ("received: %s\n", &&buffer[0]);

    var Exception.Lua? e;
    catch e do
      [[
        TABLE = load ('return{' .. @buffer .. '}')()
      ]]
      var int type = [[ TABLE.type ]];

      if  type == P_REGULAR_SEND then
        var uint from = [[ TABLE.from ]];
        var int index = [[ TABLE.index or -1 ]];

        [[ print (serialize(TABLE.payload)) ]]
        [[ m = get_mapping (TABLE.payload.evt) ]]

        var ssize len = [[ #m ]];
        var ssize i;
        loop i in [1 -> len] do
          [[
            local p = MARS.__private.peers[TABLE.from]
            ok = false
            if p ~= nil then
              local interface = m[@i][2]
              local peer_interfaces = p:getInterfaces()
              for k,v in pairs (peer_interfaces) do
                if v.interface == interface then
                  ok = true
                end
              end
            end
            if ok then
              if type(m[@i][5]) == 'function' then
                ok, mapped_args = m[@i][5](TABLE.payload.args)
              end
            end
          ]]
          var bool ok = [[ ok ]];
          if ok then
            outer.mapped_evt = [] .. [[ m[@i][3] .. '\0']];
            outer.mapped_dest = [] .. [[ (m[@i][4] or '') .. '\0' ]];

            [[
              --TODO: apply function to args
              TABLE.payload.evt = m[@i][3]
              if mapped_args then
                TABLE.payload.args = mapped_args
              end
            ]]

            outer.cur_payload = [] .. [[ serialize (TABLE.payload) ]];

            emit outer.send_broadcast_message (from, index);
          end
        end

      end
    end
    if e? then
      _printf ("[Receive error]: %s\n", e!.message);
    end
  end
end

code/await Writing_Handler (var& UV_Stream stream,
                            var&[] byte ip,
                            var int port) -> NEVER
do
  var uint handle_id = outer.id_ref;
  outer.id_ref = outer.id_ref + 1;

  outer.peers_count = outer.peers_count + 1;
  do finalize with
    outer.peers_count = outer.peers_count - 1;
  end

  pool[] Send_Not_Joined_Reply  pool_not_joined_reply;
  pool[] Send_Join_Reply        pool_join_reply;
  pool[] Send_Broadcast_Join    pool_broadcast_join;
  pool[] Send_Broadcast_Message pool_broadcast_message;
  pool[] Send_Tick_Message      pool_tick_message;

  var int status = _;

  event (none) accepted;

  par do
    loop do
      var[] byte buff;
      var bool success = await Receive (&stream, &buff);

      var Exception.Lua? e;
      catch e do
        [[ MESSAGE = load ('return {' .. @buff .. '}')() ]]
        var int type = [[ MESSAGE.type ]];

        if (type == P_JOIN) then
          [[
            status = NOT_ACCEPTED
            if MESSAGE.interfaces and MARS.__private.interfaces and
               type(MARS.__private.interfaces) == 'table' then

              interfaces = MESSAGE.interfaces
              peer = nil
              for interface in MESSAGE.interfaces:gmatch ('([^,]+)') do
                index, out = nil, ''
                if MARS.__private.interfaces[interface] ~= nil then
                  status = ACCEPTED

                  if peer == nil then
                    peer = __peers.Peer:new {id = @handle_id}
                    MARS.__private.peers[@handle_id] = peer
                  end
                  peer:addInterface (interface, index)
                end
              end
            end
            if status and type (MARS.onConnect) == 'function' then
              MARS.onConnect ()
            end
          ]]
          status = [[ status ]];

          if status == ACCEPTED then
            emit accepted ();
            spawn Send_Join_Reply (handle_id, &stream) in pool_join_reply;
            emit outer.send_broadcast_join (handle_id);
          else
            spawn Send_Not_Joined_Reply (handle_id, &stream)
                                                    in pool_not_joined_reply;
          end
          break;
        end
      end
      if e? then
        _fprintf (_stderr, "[error]: %s\n", e!.message);
      end
    end
  with
    await accepted;
    par do
      var uint freq;
      every freq in outer.send_tick_message do
        spawn Send_Tick_Message (handle_id, &stream, 50) in pool_tick_message;
      end
    with
      var uint new_id;
      every new_id in outer.send_broadcast_join do
        spawn Send_Broadcast_Join (handle_id, &stream, new_id)
                                                        in pool_broadcast_join;
      end
    with
      var uint from;
      var int index;
      var bool ok = false;
      every (from, index) in outer.send_broadcast_message do
        /* [[ */
        /*   ok = false */
        /*   local p = MARS.__private.peers[@handle_id] */
        /*   if p ~= nil then */
        /*     local out = @outer.mapped_dest */
        /*     local peer_interfaces = p:getInterfaces() */
        /*     for _,v in pairs (peer_interfaces) do */
        /*       if v.interface == out then */
        /*         ok = true */
        /*         break */
        /*       end */
        /*     end */
        /*   end */
        /* ]] */
        /* ok = [[ ok ]]; */
        /* if ok then */
        /*   _printf ("payload: %s\n", &&outer.cur_payload[0]); */

        /*   spawn Send_Broadcast_Message (handle_id, &stream, from, */
        /*                                 index, &outer.cur_payload) */
        /*                                 in pool_broadcast_message; */
        /* end */
      end
    end
  end
end

/* Handler for each client */
code/await UV_TCP_Server_Handler (var& UV_Stream stream,
                                  var& UV_TCP_Server_Data shared) -> int
do
  var int port = _;
  var _char&& ip_ptr = _mars_get_peer_net_info(&&stream.handle, &&port);
  do finalize with
    _free (ip_ptr);
  end;

  var[] byte ip = [] .. ip_ptr;

  var Exception.Uv? e;
  catch e do
    if (shared.isReading) then
      await Reading_Handler (&stream, &ip, port);
    else
      await Writing_Handler (&stream, &ip, port);
    end
  end

  if e? then
    _fprintf(_stderr, "[error]: %s\n", e!.message);
  end
end

/* We must include tcp-server after we've defined UV_TCP_Server_Handler */
#include "uv/tcp-server.ceu"

_printf ("[server] Starting server...\n");
par do
  var UV_TCP_Server_Data shared = val UV_TCP_Server_Data (true);
  await UV_TCP_Server (LOCALHOST, R_PORT, BACKLOG, _, &shared);
with
  var UV_TCP_Server_Data shared = val UV_TCP_Server_Data (false);
  await UV_TCP_Server (LOCALHOST, W_PORT, BACKLOG, _, &shared);
end

#endif
