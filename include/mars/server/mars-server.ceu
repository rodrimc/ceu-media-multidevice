#ifndef _CEU_MARS_SERVER
#define _CEU_MARS_SERVER

/* Server Lua global */
[[
  dofile ('mars-server.lua')
  dofile ('mars-util.lua')

  require 'peers'
]]

#include "mars/util/mars-defs.ceu"

native/pos do
  ##include "mars/server/mars-server.c"
end

native/nohold
  _ceu_callback_register,
  _cb,
;

_ceu_callback_register (&&_cb);

input (_char&&, _char&&) INIT;

code/await Init (none) -> int
do
  var _char&& mapping;
  var _char&& interface;
  (interface, mapping) = await INIT;

  var Exception? e;
  catch e do
    _printf ("[server] interface file: %s\n", interface);
    if interface != null then
      [[
        dofile (@interface)
      ]]
    end
  end
  if e? then
    _fprintf (_stderr, "[INTERFACES error:] %s\n", e!.message);
    escape -1;
  end

  catch e do
    _printf ("[server] mapping file: %s\n", mapping);
    if mapping != null then
      [[
        dofile (@mapping)
      ]]
    end
  end
  if e? then
    _fprintf (_stderr, "[MAPPING error:] %s\n", e!.message);
  end

  escape 0;
end

var int ret = await Init();
if ret != 0 then
  escape ret;
end

data UV_TCP_Server_Data with
  var bool isReading;
end

/*** SERVER SIDE ***/
event (uint) incoming_message;
event (uint) send_broadcast_join;
event (uint) send_tick_message;

var[] byte mapped_evt = _;
var[] byte mapped_dest = _;
var[] byte message_payload = _;

var uint id_ref = 1;
var usize peers_count = 0;

#include "messages-server.ceu"

code/await Reading_Handler (var& UV_Stream stream,
                            var&[] byte ip,
                            var int port) -> NEVER
do
  loop do
    var[] byte buffer;
    var bool success = await Receive (&stream, &buffer);

    if not success then
      continue;
    end
    _printf ("received: %s\n", &&buffer[0]);

    var Exception.Lua? e;
    catch e do
      [[
        TABLE = load ('return{' .. @buffer .. '}')()
      ]]
      var int type = [[ TABLE.type ]];

      if type == P_REGULAR_SEND then
        var uint from = [[ TABLE.from ]];
        [[ MARS.incoming_payload = TABLE.payload ]]

        emit outer.incoming_message (from);
      end
    end
    if e? then
      _printf ("[Receive error]: %s\n", e!.message);
    end
  end
end

code/await Writing_Handler (var& UV_Stream stream,
                            var&[] byte ip,
                            var int port) -> NEVER
do
  var uint handle_id = outer.id_ref;
  outer.id_ref = outer.id_ref + 1;

  outer.peers_count = outer.peers_count + 1;
  do finalize with
    outer.peers_count = outer.peers_count - 1;
  end

  pool[] Send_Not_Joined_Reply  pool_not_joined_reply;
  pool[] Send_Join_Reply        pool_join_reply;
  pool[] Send_Broadcast_Join    pool_broadcast_join;
  pool[] Send_Message           pool_send_message;
  pool[] Send_Tick_Message      pool_tick_message;

  var int status = _;

  event (none) accepted;

  par do
    loop do
      var[] byte buff;
      var bool success = await Receive (&stream, &buff);

      var Exception.Lua? e;
      catch e do
        [[ MESSAGE = load ('return {' .. @buff .. '}')() ]]
        var int type = [[ MESSAGE.type ]];

        if (type == P_JOIN) then
          [[
            status = NOT_ACCEPTED
            if MESSAGE.interfaces and MARS.interfaces and
               type(MARS.interfaces) == 'table' then

              interfaces = MESSAGE.interfaces
              peer = nil
              for i in MESSAGE.interfaces:gmatch ('([^,]+)') do
                if MARS.interfaces[i] ~= nil then
                  interface = MARS.interfaces[i]
                  status = ACCEPTED

                  if peer == nil then
                    peer = Peer:new {
                      id = @handle_id,
                      ip = @ip,
                      port = @port
                    }
                    MARS.peers[@handle_id] = peer
                  end
                  peer:addInterface (i, interface)
                end
              end
            end
            if status == ACCEPTED and type (MARS.onConnect) == 'function' then
              MARS.onConnect (peer)
            end
          ]]

          status = [[ status ]];
          if status == ACCEPTED then
            emit accepted ();
            spawn Send_Join_Reply (handle_id, &stream) in pool_join_reply;
            emit outer.send_broadcast_join (handle_id);
          else
            spawn Send_Not_Joined_Reply (handle_id, &stream)
                                                    in pool_not_joined_reply;
          end
          break;
        end
      end
      if e? then
        _fprintf (_stderr, "[error]: %s\n", e!.message);
      end
    end
  with
    await accepted;
    par do
      var uint freq;
      every freq in outer.send_tick_message do
        spawn Send_Tick_Message (handle_id, &stream, 50) in pool_tick_message;
      end
    with
      var uint new_id;
      every new_id in outer.send_broadcast_join do
        spawn Send_Broadcast_Join (handle_id, &stream, new_id)
                                                        in pool_broadcast_join;
      end
    with
      var Exception.Lua? e;
      catch e
      do
        var uint from;
        var ssize len = 0;
        var bool ok = false;
        every (from) in outer.incoming_message do
          [[
            local p = MARS.peers[@from]
            mymap = {}
            if p~= nil then
              m = p.__mapping[MARS.incoming_payload.evt]
              if m ~= nil then
                for _,v in ipairs (m) do
                  if v.to == @handle_id then
                    table.insert (mymap, v)
                  end
                end
              end
            end
          ]]

          len = [[ #mymap ]];

          var ssize i;
          loop i in [1 -> len] do
            [[
              ok = true
              args = MARS.incoming_payload.args
              if type (mymap[@i].transform) == 'function' then
                ok, args = mymap[@i].transform (MARS.peers[@from],
                                                table.unpack(MARS.incoming_payload.args))
              end
            ]]
            ok = [[ ok ]];
            if ok then
              outer.message_payload = [] .. [[ (serialize({
                    evt = mymap[@i].evt,
                    args = args
                  })) ]];
              _printf ("sending: %s\n", &&outer.message_payload[0]);
              spawn Send_Message (handle_id, &stream, &outer.message_payload)
                                                          in pool_send_message;
            end
          end
        end
      end
      if e? then
        _printf ("[Incoming Message error:] %s\n", e!.message);
      end
    end
  end
end

/* Handler for each client */
code/await UV_TCP_Server_Handler (var& UV_Stream stream,
                                  var& UV_TCP_Server_Data shared) -> int
do
  var[] byte ip = _;
  var u16 port = await Get_Net_Address (&stream, &ip);

  _printf ("%s:%u\n", &&ip[0], port);

  if (shared.isReading) then
    await Reading_Handler (&stream, &ip, port as int);
  else
    await Writing_Handler (&stream, &ip, port as int);
  end

end

/* We must include tcp-server after we've defined UV_TCP_Server_Handler */
#include "uv/tcp-server.ceu"

_printf ("[server] Starting server...\n");
par do
  var UV_TCP_Server_Data shared = val UV_TCP_Server_Data (true);
  await UV_TCP_Server (LOCALHOST, R_PORT, BACKLOG, _, &shared);
with
  var UV_TCP_Server_Data shared = val UV_TCP_Server_Data (false);
  await UV_TCP_Server (LOCALHOST, W_PORT, BACKLOG, _, &shared);
end

#endif
