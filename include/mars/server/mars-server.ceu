#ifndef _CEU_MARS_SERVER
#define _CEU_MARS_SERVER

/* Server Lua global */
[[
  dofile ('mars-server.lua')

  __peers = require 'peers'

  SERVER =
    {
      peers = {},
      devices = {},
      mapping = nil,
      interface = nil,
      handler_interfaces = {},
    }
]]

#include "mars/util/mars-defs.ceu"

native/pre do
  ##include <sys/socket.h>

  typedef struct sockaddr_in6 sockaddr_in6;
end

native/pos do
  ##include "mars/server/native-pre-server.c"
end

native/plain
  _AF_INET,
  _AF_INET6,
  _INET_ADDRSTRLEN,
  _INET6_ADDRSTRLEN,
  _sockaddr_in6,
;

native/nohold
  _uv_ip6_name,
  _uv_tcp_getpeername,
  _ceu_callback_register,
  _cb,
;

_ceu_callback_register (&&_cb);

input (_char&&, _char&&) INIT;

code/await Init (none) -> int
do
  var _char&& mapping;
  var _char&& interface;
  (interface, mapping) = await INIT;

  var Exception? e;
  catch e do
    _printf ("[server] interface file: %s\n", interface);
    if interface != null then
      [[
        dofile (@interface)
      ]]
    end
  end
  if e? then
    _fprintf (_stderr, "[INTERFACES error:] %s\n", e!.message);
    escape -1;
  end

  catch e do
    _printf ("[server] mapping file: %s\n", mapping);
    if mapping != null then
      [[
        dofile (@mapping)
      ]]
    end
  end
  if e? then
    _fprintf (_stderr, "[MAPPING error:] %s\n", e!.message);
  end

  escape 0;
end

var int ret = await Init();
if ret != 0 then
  escape ret;
end

data UV_TCP_Server_Data with
  var bool isReading;
end

/*** SERVER SIDE ***/
event (uint) send_broadcast_join;
event (uint, int) send_broadcast_message;
event (uint) send_tick_message;

var[] byte mapped_evt = _;
var[] byte mapped_dest = _;
var[] byte cur_payload;
var[] byte cur_interface;

var uint id_ref = 1;
var usize peers_count = 0;

#include "messages-server.ceu"

code/await Reading_Handler (var& UV_Stream stream,
                            var&[] byte ip,
                            var int port) -> NEVER
do
  loop do
    var[] byte buffer;
    var bool success = await Receive (&stream, &buffer);

    if not success then
      continue;
    end
    _printf ("received: %s\n", &&buffer[0]);

    var Exception.Lua? e;
    catch e do
      [[
        TABLE = load ('return{' .. @buffer .. '}')()
      ]]
      var int type = [[ TABLE.type ]];

      if type == P_REGULAR_SEND then
        var uint from = [[ TABLE.from ]];
        var int index = [[ TABLE.index or -1 ]];

        [[ print (serialize(TABLE.payload)) ]]
        [[ m = get_mapping (TABLE.payload.evt) ]]

        var ssize len = [[ #m ]];
        var ssize i;
        loop i in [1 -> len] do
          [[
            local p = MARS.__private.peers[TABLE.from]
            ok = false
            if p ~= nil then
              local interface = m[@i][2]
              local peer_interfaces = p:getInterfaces()
              for k,v in pairs (peer_interfaces) do
                if v.interface == interface then
                  ok = true
                end
              end
            end
            if ok then
              if type(m[@i][5]) == 'function' then
                ok, mapped_args = m[@i][5](TABLE.payload.args)
              end
            end
          ]]
          var bool ok = [[ ok ]];
          if ok then
            outer.mapped_evt = [] .. [[ m[@i][3] .. '\0']];
            outer.mapped_dest = [] .. [[ (m[@i][4] or '') .. '\0' ]];

            [[
              --TODO: apply function to args
              TABLE.payload.evt = m[@i][3]
              if mapped_args then
                TABLE.payload.args = mapped_args
              end
            ]]

            outer.cur_payload = [] .. [[ serialize (TABLE.payload) ]];

            emit outer.send_broadcast_message (from, index);
          end
        end

      end
    end
    if e? then
      _printf ("[Receive error]: %s\n", e!.message);
    end
  end
end

code/await Writing_Handler (var& UV_Stream stream,
                            var&[] byte ip,
                            var int port) -> NEVER
do
  var uint handle_id = outer.id_ref;
  outer.id_ref = outer.id_ref + 1;

  outer.peers_count = outer.peers_count + 1;
  do finalize with
    outer.peers_count = outer.peers_count - 1;
  end

  pool[] Send_Not_Joined_Reply  pool_not_joined_reply;
  pool[] Send_Join_Reply        pool_join_reply;
  pool[] Send_Broadcast_Join    pool_broadcast_join;
  pool[] Send_Broadcast_Message pool_broadcast_message;
  pool[] Send_Tick_Message      pool_tick_message;

  var int status = _;

  event (none) accepted;

  par do
    loop do
      var[] byte buff;
      var bool success = await Receive (&stream, &buff);

      var Exception.Lua? e;
      catch e do
        [[ MESSAGE = load ('return {' .. @buff .. '}')() ]]
        var int type = [[ MESSAGE.type ]];

        if (type == P_JOIN) then
          [[
            status = NOT_ACCEPTED
            if MESSAGE.interfaces and MARS.__private.interfaces and
               type(MARS.__private.interfaces) == 'table' then

              interfaces = MESSAGE.interfaces
              peer = nil
              for interface in MESSAGE.interfaces:gmatch ('([^,]+)') do
                index, out = nil, ''
                if MARS.__private.interfaces[interface] ~= nil then
                  status = ACCEPTED

                  if peer == nil then
                    peer = __peers.Peer:new {id = @handle_id}
                    MARS.__private.peers[@handle_id] = peer
                  end
                  peer:addInterface (interface, index)
                end
              end
            end
            if status and type (MARS.onConnect) == 'function' then
              MARS.onConnect ()
            end
          ]]
          status = [[ status ]];

          if status == ACCEPTED then
            emit accepted ();
            spawn Send_Join_Reply (handle_id, &stream) in pool_join_reply;
            emit outer.send_broadcast_join (handle_id);
          else
            spawn Send_Not_Joined_Reply (handle_id, &stream)
                                                    in pool_not_joined_reply;
          end
          break;
        end
      end
      if e? then
        _fprintf (_stderr, "[error]: %s\n", e!.message);
      end
    end
  with
    await accepted;
    par do
      var uint freq;
      every freq in outer.send_tick_message do
        spawn Send_Tick_Message (handle_id, &stream, 50) in pool_tick_message;
      end
    with
      var uint new_id;
      every new_id in outer.send_broadcast_join do
        spawn Send_Broadcast_Join (handle_id, &stream, new_id)
                                                        in pool_broadcast_join;
      end
    with
      var uint from;
      var int index;
      var bool ok = false;
      every (from, index) in outer.send_broadcast_message do
        /* [[ */
        /*   ok = false */
        /*   local p = MARS.__private.peers[@handle_id] */
        /*   if p ~= nil then */
        /*     local out = @outer.mapped_dest */
        /*     local peer_interfaces = p:getInterfaces() */
        /*     for _,v in pairs (peer_interfaces) do */
        /*       if v.interface == out then */
        /*         ok = true */
        /*         break */
        /*       end */
        /*     end */
        /*   end */
        /* ]] */
        /* ok = [[ ok ]]; */
        /* if ok then */
        /*   _printf ("payload: %s\n", &&outer.cur_payload[0]); */

        /*   spawn Send_Broadcast_Message (handle_id, &stream, from, */
        /*                                 index, &outer.cur_payload) */
        /*                                 in pool_broadcast_message; */
        /* end */
      end
    end
  end
end

/* Handler for each client */
code/await UV_TCP_Server_Handler (var& UV_Stream stream,
                                  var& UV_TCP_Server_Data shared) -> int
do
  var _sockaddr_storage sock = _;
  var int len = sizeof(_sockaddr_in) as int;
  var int ret = _uv_tcp_getpeername(&&stream.handle as _uv_tcp_t&&,
    (&&sock as _sockaddr&&), &&len);
  _ceu_sys_assert(ret == 0, "could not get socket peer name");

  /* INET6_ADDRSTRLEN is supposed to be large enough to accommodate ipv4 and ipv6 */
  var[] byte ip = _;
  var u16 port = _;

  if sock.ss_family == _AF_INET then
    var _sockaddr_in&& src = &&sock as _sockaddr_in &&;
    var[_INET_ADDRSTRLEN] byte tmp = _;

    ret = _uv_ip4_name(src, &&tmp[0], _INET_ADDRSTRLEN);
    _ceu_sys_assert(ret == 0, "could not get ipv4 name");

    ip = [] .. &&tmp[0] as _char&&;

    port = _ntohs(src:sin_port);
  else/if sock.ss_family == _AF_INET6 then
    var _sockaddr_in6&& src = &&sock as _sockaddr_in6 &&;
    var[_INET6_ADDRSTRLEN] byte tmp = _;

    ret = _uv_ip6_name(src, &&ip[0], _INET6_ADDRSTRLEN);
    _ceu_sys_assert(ret == 0, "could not get ipv6 name");

    ip = [] .. &&tmp[0] as _char&&;

    port = _ntohs(src:sin6_port);
  end

  _printf ("Client Socket: %s:%d\n", &&ip[0], port);

  if (shared.isReading) then
    await Reading_Handler (&stream, &ip, port as int);
  else
    await Writing_Handler (&stream, &ip, port as int);
  end

end

/* We must include tcp-server after we've defined UV_TCP_Server_Handler */
#include "uv/tcp-server.ceu"

_printf ("[server] Starting server...\n");
par do
  var UV_TCP_Server_Data shared = val UV_TCP_Server_Data (true);
  await UV_TCP_Server (LOCALHOST, R_PORT, BACKLOG, _, &shared);
with
  var UV_TCP_Server_Data shared = val UV_TCP_Server_Data (false);
  await UV_TCP_Server (LOCALHOST, W_PORT, BACKLOG, _, &shared);
end

#endif
