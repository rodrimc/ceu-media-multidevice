#ifndef _CEU_MARS_SERVER
#define _CEU_MARS_SERVER

#include "mars-defs.ceu"

#include "uv/tcp.ceu"

data UV_TCP_Server_Data with
  var bool isReading;
end

/*** SERVER SIDE ***/
event (none) send_join_reply;
event (uint) send_broadcast_join;
event (uint) send_broadcast_message;
event (uint) message_sent;

var uint seq_num = 0;
var bool is_sending_message = false;
var []byte cur_payload;

var uint id_ref = 1;
var usize peers_count = 0;


code/await Send (var& UV_Stream client, var&[] byte buffer) -> none
do
  var uint my_seq_num = outer.seq_num;
  outer.seq_num = outer.seq_num + 1;

  if outer.is_sending_message then
    var uint seq = await outer.message_sent until seq == my_seq_num - 1;
  end

  client.buffer = [] .. buffer .. "\n";

  outer.is_sending_message = true;

  _log ("[server] sending: %s\n", &&buffer[0]);
  await UV_Stream_Write_N (&client, _);
  call R_Clear_Vec (&client.buffer);

  outer.is_sending_message = false;
  emit outer.message_sent (my_seq_num);
end

code/await Send_Join_Reply (var& UV_Stream client, var uint id) -> none
do
  var[] byte buf = [] .. "return {type=";
  var[] byte tmp = [] .. [[ tostring (@S_JOINED) .. '\0']];

  call R_Vec_Cat (&buf, &tmp);

  tmp = [] .. ",id=";
  call R_Vec_Cat (&buf, &tmp);

  tmp = [] .. [[ tostring (@id) .. '\0']];
  call R_Vec_Cat (&buf, &tmp);

  tmp = [] .. ",peers=";
  call R_Vec_Cat (&buf, &tmp);

  tmp = [] .. [[ tostring (@outer.peers_count) .. '\0']];
  call R_Vec_Cat (&buf, &tmp);

  tmp = [] .. "}";
  call R_Vec_Cat (&buf, &tmp);

  await Send (&client, &buf);
end

code/await Send_Broadcast_Join (var& UV_Stream client, var uint id) -> none
do
  var[] byte buf = [] .. "return {type=";
  var[] byte tmp = [] .. [[ tostring (@S_NEW_PEER) .. '\0']];

  call R_Vec_Cat (&buf, &tmp);

  tmp = [] .. ",new_peer=";
  call R_Vec_Cat (&buf, &tmp);

  tmp = [] .. [[ tostring (@id) .. '\0']];
  call R_Vec_Cat (&buf, &tmp);

  tmp = [] .. ",peers=";
  call R_Vec_Cat (&buf, &tmp);

  tmp = [] .. [[ tostring (@outer.peers_count) .. '\0']];
  call R_Vec_Cat (&buf, &tmp);

  tmp = [] .. ",timestamp=";
  call R_Vec_Cat (&buf, &tmp);

  var u64 ts = _now ();

  tmp = [] .. [[ tostring (@ts) .. '\0']];
  call R_Vec_Cat (&buf, &tmp);

  tmp = [] .. "}";
  call R_Vec_Cat (&buf, &tmp);

  await Send (&client, &buf);
end

code/await Send_Broadcast_Message (var& UV_Stream client, var uint from,
                                   var& []byte payload) -> none
do
  var[] byte buf = [] .. "return {type=";
  var[] byte tmp = [] .. [[ tostring (@S_BROADCAST) .. '\0']];

  call R_Vec_Cat (&buf, &tmp);

  tmp = [] .. ",from=";
  call R_Vec_Cat (&buf, &tmp);

  tmp = [] .. [[ tostring (@from) .. '\0']];
  call R_Vec_Cat (&buf, &tmp);

  tmp = [] .. ",payload=";
  call R_Vec_Cat (&buf, &tmp);

  tmp = [] .. payload;
  call R_Vec_Cat (&buf, &tmp);

  tmp = [] .. ",timestamp=";
  call R_Vec_Cat (&buf, &tmp);

  var u64 ts = _now ();
  tmp = [] .. [[ tostring (@ts) .. '\0']];
  call R_Vec_Cat (&buf, &tmp);

  tmp = [] .. "}";
  call R_Vec_Cat (&buf, &tmp);

  await Send (&client, &buf);

end

code/await Reading_Handler (var& UV_Stream client) -> NEVER
do
  loop do
    var [] byte buffer;
    call R_Clear_Vec (&client.buffer);

    await UV_Stream_Read_Line (&client, &buffer);
    _log ("[server] received: %s\n", &&buffer[0]);

    var int type = _;

    [[ TABLE =  load (@buffer)() ]]
    type = [[ TABLE.type ]];

    if type == P_JOIN then
      emit outer.send_join_reply;
    else/if type == P_REGULAR_SEND then
      var int from = [[ TABLE.from ]];
      var [] byte payload = [] .. [[ serialize(TABLE.payload) ]];

      outer.cur_payload = [] .. payload;
      emit outer.send_broadcast_message (from);
    end
  end
end

code/await Writing_Handler (var& UV_Stream client) -> NEVER
do
  var uint id = outer.id_ref;
  outer.id_ref = outer.id_ref + 1;

  outer.peers_count = outer.peers_count + 1;
  do finalize with
    outer.peers_count = outer.peers_count - 1;
  end

  pool[] Send_Join_Reply        pool_join_reply;
  pool[] Send_Broadcast_Join    pool_broadcast_join;
  pool[] Send_Broadcast_Message pool_broadcast_message;

  par do
    every outer.send_join_reply do
      spawn Send_Join_Reply (&client, id) in pool_join_reply;
      emit outer.send_broadcast_join (id);
    end
  with
    var uint new_id;
    every new_id in outer.send_broadcast_join do
      spawn Send_Broadcast_Join (&client, new_id)
            in pool_broadcast_join;
    end
  with
    var uint from;
    every from in outer.send_broadcast_message do
      spawn Send_Broadcast_Message (&client, from, &outer.cur_payload)
            in pool_broadcast_message;
    end
  with
#if 0
    var uint freq;
    every freq in outer.send_tick_message do
      spawn Send_Tick_Message (&client, freq) in pool_tick_message;
    end
#endif
  end
end

/* Handler for each client */
code/await UV_TCP_Server_Handler (var& UV_Stream client,
                                  var& UV_TCP_Server_Data shared) -> int
do
  if (shared.isReading) then
    await Reading_Handler (&client);
  else
    await Writing_Handler (&client);
  end

end

/* We must include tcp-server after we've defined UV_TCP_Server_Handler */
#include "uv/tcp-server.ceu"

#endif
