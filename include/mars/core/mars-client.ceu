#ifndef _CEU_MARS_CLIENT
#define _CEU_MARS_CLIENT

#include "uv/uv.ceu"
#include "uv/tcp.ceu"

#include "mars-defs.ceu"

/*** CLIENT API ***/
data IStub with
  var& UV_Stream tcp;
  var uint id;
  var&[] byte wbuffer;
  var&[] byte rbuffer;
  var&[] byte message;
  event (uint, usize) joined;
  event (uint, usize) new_peer;
  event (none) incoming_message;
end

code/await Stub_Send_Message (var& IStub stub) -> none
do
  var[] byte buf = [] .. "return {type=";

  var[] byte tmp = [] .. [[ tostring (@P_REGULAR_SEND) ]];
  call R_Vec_Cat (&buf, &tmp);

  tmp = [] .. ",payload=";
  call R_Vec_Cat (&buf, &tmp);

  tmp = [] .. stub.wbuffer;
  call R_Vec_Cat (&buf, &tmp);

  tmp = [] .. ",from=";
  call R_Vec_Cat (&buf, &tmp);

  tmp = [] .. [[ tostring (@stub.id) ]];
  call R_Vec_Cat (&buf, &tmp);

  tmp = [] .. ",timestamp=";
  call R_Vec_Cat (&buf, &tmp);

  var u64 ts = _now();
  tmp = [] .. [[ tostring (@ts) ]];
  call R_Vec_Cat (&buf, &tmp);

  tmp = [] .. "}";
  call R_Vec_Cat (&buf, &tmp);

  stub.tcp.wBuffer = [] .. buf .. "\n";

  _log ("[Stub (%d)] sending: %s\n", stub.id, &&stub.tcp.wBuffer[0]);
  await UV_Stream_Write_N(&stub.tcp, _);
end

code/await Handle_Message (var&[] byte buffer, var& IStub ref_) -> none
do
  var usize i;
  var int type = _;

  /* parse message */
  [[ TABLE =  load (@buffer)()]]
  type = [[ TABLE.type ]];

  _log ("type: %d\n", type);

  if type == S_JOINED then
    ref_.id = [[ TABLE.id ]];
    var int peers = [[ TABLE.peers ]];
    emit ref_.joined (ref_.id, peers);

  else/if type == S_NEW_PEER then
    var int new_peer = [[ TABLE.peers ]];
    var int peers = [[ TABLE.peers ]];
    emit ref_.new_peer (new_peer, peers);

  else/if type == S_BROADCAST then
    ref_.message= [] .. "return";
    var[] byte buf = [] .. [[serialize (TABLE.payload)]];

    call R_Vec_Cat (&ref_.message, &buf);
    emit ref_.incoming_message;
  else
    _log ("[Stub (%d) Unknow message type.\n", ref_.id);
  end

  ref_.message = [] .. "";
  $ref_.tcp.rBuffer = 0;
end

code/await Stub (var _char&& ip, var int port, var int session)
                          -> (var& IStub stub)
                            -> none
do
  var&? UV_TCP_Connect connection = spawn UV_TCP_Connect(ip, port, _);
  watching connection do
    var[] byte rbuffer;
    var[] byte wbuffer;
    var[] byte message;
    var IStub ref_ = val IStub (&connection.stream, 0, &rbuffer, &wbuffer,
                                &message, _, _, _);
    stub = &ref_;

    await connection.ok;

    par do
      var[] byte buf = [] .. "return {type=";
      var[] byte tmp = [] .. [[ tostring(@P_JOIN) ]];

      call R_Vec_Cat (&buf, &tmp);

      tmp = [] .. "}";
      call R_Vec_Cat (&buf, &tmp);

      ref_.tcp.wBuffer = [] .. buf .. "\n";

      /* send P_JOIN message */
      _log ("[Stub (%d)] sending %s\n", ref_.id, &&ref_.tcp.wBuffer[0]);
      await UV_Stream_Write_N(&ref_.tcp, _);
    with
      /* await message */
      pool [] Handle_Message pool_handle_message;
      loop do
        var [] byte buffer;
        call R_Clear_Vec (&ref_.tcp.rBuffer);
        await UV_Stream_Read_Line(&ref_.tcp, &buffer);

        _log ("[Stub (%d)] received: %s\n", ref_.id, &&buffer[0]);
        spawn Handle_Message (&buffer, &ref_) in pool_handle_message;
      end
    end
  end
end

#endif
