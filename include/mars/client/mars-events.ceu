var uint device_id  = 0;
var uint evt_dev_id = 0;
var[] byte evt_dev_role = _;
var int evt_dev_role_index = -1;

[[
  function get_mapping (evt)
    local map = {} 
    if type(CLIENT.mapping.events) == 'table' then
      for k,v in pairs (CLIENT.mapping.events) do
        if v[1] == evt then
          table.insert(map, v)
        end
      end
    end
    return map
  end

  function get_mapping_indices (evt)
    local indices = {} 
    if type(CLIENT.mapping.events) == 'table' then
      for i=1, #CLIENT.mapping.events do
        if CLIENT.mapping.events[i][1] == evt then
          table.insert(indices, i)
        end
      end
    end
    return indices
  end

  function has_mapping (evt, role, is_local)
    map = get_mapping (evt)

    for i=1, #map do
      if is_local then
        if map[i][2] == role then
          return true
        end
      else
        if map[i][2] == role and map[i][4] == CLIENT.role.name then
          return true
        end
      end
    end
    return false
  end

  function apply_mapping (evtFrom, evtTo)
    local toEmit = true
    local args = CLIENT.remote.args

    local map = get_mapping (evtFrom)
    local m
    for i=1, #map do
      if map[i][3] == evtTo then
        m = map[i]
        break
      end
    end

    if m == nil then
      print ("you're not supposed to get here")
      return false 
    end

    local func = m[5] or nil

    CLIENT.mapping.args = args
    if type (func) == 'function' then
      toEmit, mapped = func (args)
      if toEmit then
        CLIENT.mapping.args = mapped or args
      end
    end
    return toEmit
  end

  function pack (evt, ...)
    local args = {...}
    local packed = {evt = evt, args = {}}
    for i = 1, #args do
      table.insert (packed.args, args[i])
    end
    local serialized = serialize (packed)
    return serialized
  end

]]

/* Scene */
event (uint, int, int, int, bool) mars_scene_mouse_clicked;
event (uint, _char_ptr_ext, bool) mars_scene_key;

event (uint, uint, _char_ptr_ext, bool) create_evt_scene_key;
event (uint, uint, int, int, int, bool) create_evt_scene_mouse_clicked;

/* Player */
event (uint, int, int, int, bool) mars_player_mouse_clicked;

event (uint, uint, int, int, int, bool) create_evt_player_mouse_clicked;

/* SCENE INPUT EVENTS */
input (uint, int, int, int, bool)   CM_SCENE_MOUSE_CLICK;
input (uint, int, int)              CM_SCENE_MOUSE_MOVE;
input (uint, _char_ptr_ext, bool)   CM_SCENE_KEY;
input (uint, u64)                   CM_SCENE_TICK;
input (_char_ptr_ext)               CM_SCENE_ERROR;

/* PLAYER INPUT EVENTS */
input (uint)                        CM_PLAYER_START;
input (uint)                        CM_PLAYER_STOP;
input (uint)                        CM_PLAYER_PAUSE;
input (uint)                        CM_PLAYER_SOUGHT;
input (uint, int, int, int, bool)   CM_PLAYER_MOUSE_CLICK;

/* async emits wrapped in code/awaits */
code/await Emit_Scene_Key_Event (var uint device, var uint obj,
                                 var _char_ptr_ext key, var bool press) -> none
do
  var&? _char buff = &_strdup (key)
    finalize (buff) with
      _free (&&buff!);
    end;

  await async (device, obj, buff, press) do
    outer.evt_dev_id = device;
    emit CM_SCENE_KEY (obj, buff, press);
  end
end

code/await Emit_Scene_Error_Event (var uint device,
                                   var _char_ptr_ext error) -> none
do
  var&? _char_ptr_ext buff = &_strdup (error)
    finalize (buff) with
      if buff? then
        _free (buff!);
      end
    end;

  await async (device, buff) do
    outer.evt_dev_id = device;
    emit CM_SCENE_ERROR (buff);
  end
end

code/await Emit_Scene_Mouse_Move_Event (var uint device,
                                        var uint id,
                                        var int x,
                                        var int y) -> none
do
  await async (device, id, x, y) do
    outer.evt_dev_id = device;
    emit CM_SCENE_MOUSE_MOVE (id, x, y);
  end
end

code/await Emit_Scene_Mouse_Click_Event (var uint device,
                                         var uint id,
                                         var int x,
                                         var int y,
                                         var int button,
                                         var bool press) -> none
do
  await async (device, id, x, y, button, press) do
    outer.evt_dev_id = device;
    emit CM_SCENE_MOUSE_CLICK (id, x, y, button, press);
  end
end

code/await Emit_Scene_Tick_Event (var uint device,
                                  var uint id,
                                  var u64 tick) -> none
do
  await async (device, id, tick) do
    outer.evt_dev_id = device;
    emit CM_SCENE_TICK (id, tick);
  end
end

code/await Emit_Player_Start_Event (var uint device,
                                    var uint id) -> none
do
  await async (device, id) do
    outer.evt_dev_id = device;
    emit CM_PLAYER_START (id);
  end
end

code/await Emit_Player_Stop_Event (var uint device,
                                   var uint id) -> none
do
  await async (device, id) do
    outer.evt_dev_id = device;
    emit CM_PLAYER_STOP (id);
  end
end

code/await Emit_Player_Sought_Event (var uint device,
                                     var uint id) -> none
do
  await async (device, id) do
    outer.evt_dev_id = device;
    emit CM_PLAYER_SOUGHT (id);
  end
end

code/await Emit_Player_Mouse_Click_Event (var uint device,
                                          var uint id,
                                          var int x,
                                          var int y,
                                          var int button,
                                          var bool press) -> none
do
  await async (device, id, x, y, button, press) do
    outer.evt_dev_id = device;
    emit CM_PLAYER_MOUSE_CLICK (id, x, y, button, press);
  end
end

code/await Input_Events_Manager (none) -> none
do
  par do
    /* KEY */
    var uint device;
    var uint id;
    var _char_ptr_ext key;
    var bool press;
    pool [] Emit_Scene_Key_Event scene_key_event_pool;
    every (device, id, key, press) in outer.create_evt_scene_key do
      spawn Emit_Scene_Key_Event (device, id, key, press)
                                  in scene_key_event_pool;
    end
  with
    /* MOUSE CLICKED */
    var uint device = 0;
    var uint id = 0;
    var int x = 0;
    var int y = 0;
    var int button = 0;
    var bool press = false;

    par do
      pool [] Emit_Scene_Mouse_Click_Event scene_mouse_click_event_pool;
      every (device, id, x, y, button, press)
                                   in outer.create_evt_scene_mouse_clicked do
        spawn Emit_Scene_Mouse_Click_Event (device, id, x, y, button, press)
                                            in scene_mouse_click_event_pool;
      end
    with
      pool [] Emit_Player_Mouse_Click_Event player_mouse_click_event_pool;
      every (device, id, x, y, button, press)
                                   in outer.create_evt_player_mouse_clicked do
        spawn Emit_Player_Mouse_Click_Event (device, id, x, y, button, press)
                                            in player_mouse_click_event_pool;
      end
    end
  end
end

code/tight Has_Mapping (var _char&& evt,
                        var& []byte role,
                        var bool is_local) -> bool
do
  var bool has_mapping = false;
  has_mapping = [[ has_mapping (@evt, @role, @is_local) ]];

  escape has_mapping;
end

code/tight Get_Mapping_Indices (var _char&& evt, var& []int mapping) -> none
do
  [[
    indices = get_mapping_indices (@evt)
  ]]
  var int len = [[ #indices ]];
  var ssize i;
  $mapping = 0;
  loop i in [1 -> len] do
    var int index = [[ indices[@i] ]];
    mapping = mapping .. [ index ];
  end
end
