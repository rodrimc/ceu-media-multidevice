var uint device_id  = 0;
var uint evt_dev_id = 0;
var[] byte evt_dev_role = _;

[[
  function get_mapping (evt)
    if type(CLIENT.mapping.events) == 'table' then
      for k,v in pairs (CLIENT.mapping.events) do
        if v[1] == evt then
          return v
        end
      end
    end
    return nil
  end

  function has_mapping (evt, role, is_local)
    map = get_mapping (evt)

    if map == nil then
      return false
    elseif is_local then
      return map[2] == role
    else
      return map[2] == role and map[3] == CLIENT.role.name
    end
  end

  function apply_mapping (evt)
    local args = {}
    for k, v in pairs (TABLE) do
      args[k] = v
    end

    CLIENT.mapping.args = {}
    if type (CLIENT.mapping.apply) == 'function' then
      CLIENT.mapping.apply (evt, args)
    end
  end
]]

/* Scene */
event (uint, int, int, int, bool) mars_scene_mouse_clicked;
event (uint, _char_ptr_ext, bool) mars_scene_key;

event (uint, uint, _char_ptr_ext, bool) create_evt_scene_key;
event (uint, uint, int, int, int, bool) create_evt_scene_mouse_clicked;

/* Player */
event (uint, int, int, int, bool) mars_player_mouse_clicked;

event (uint, uint, int, int, int, bool) create_evt_player_mouse_clicked;

/* SCENE INPUT EVENTS */
input (uint, int, int, int, bool)   CM_SCENE_MOUSE_CLICK;
input (uint, int, int)              CM_SCENE_MOUSE_MOVE;
input (uint, _char_ptr_ext, bool)   CM_SCENE_KEY;
input (uint, u64)                   CM_SCENE_TICK;
input (_char_ptr_ext)               CM_SCENE_ERROR;

/* PLAYER INPUT EVENTS */
input (uint)                        CM_PLAYER_START;
input (uint)                        CM_PLAYER_STOP;
input (uint)                        CM_PLAYER_PAUSE;
input (uint)                        CM_PLAYER_SOUGHT;
input (uint, int, int, int, bool)   CM_PLAYER_MOUSE_CLICK;

/* async emits wrapped in code/awaits */
code/await Emit_Scene_Key_Event (var uint device, var uint obj,
                                 var _char_ptr_ext key, var bool press) -> none
do
  var&? _char buff = &_strdup (key)
    finalize (buff) with
      _free (&&buff!);
    end;

  await async (device, obj, buff, press) do
    outer.evt_dev_id = device;
    emit CM_SCENE_KEY (obj, buff, press);
  end
end

code/await Emit_Scene_Error_Event (var uint device,
                                   var _char_ptr_ext error) -> none
do
  var&? _char_ptr_ext buff = &_strdup (error)
    finalize (buff) with
      if buff? then
        _free (buff!);
      end
    end;

  await async (device, buff) do
    outer.evt_dev_id = device;
    emit CM_SCENE_ERROR (buff);
  end
end

code/await Emit_Scene_Mouse_Move_Event (var uint device,
                                        var uint id,
                                        var int x,
                                        var int y) -> none
do
  await async (device, id, x, y) do
    outer.evt_dev_id = device;
    emit CM_SCENE_MOUSE_MOVE (id, x, y);
  end
end

code/await Emit_Scene_Mouse_Click_Event (var uint device,
                                         var uint id,
                                         var int x,
                                         var int y,
                                         var int button,
                                         var bool press) -> none
do
  await async (device, id, x, y, button, press) do
    outer.evt_dev_id = device;
    emit CM_SCENE_MOUSE_CLICK (id, x, y, button, press);
  end
end

code/await Emit_Scene_Tick_Event (var uint device,
                                  var uint id,
                                  var u64 tick) -> none
do
  await async (device, id, tick) do
    outer.evt_dev_id = device;
    emit CM_SCENE_TICK (id, tick);
  end
end

code/await Emit_Player_Start_Event (var uint device,
                                    var uint id) -> none
do
  await async (device, id) do
    outer.evt_dev_id = device;
    emit CM_PLAYER_START (id);
  end
end

code/await Emit_Player_Stop_Event (var uint device,
                                   var uint id) -> none
do
  await async (device, id) do
    outer.evt_dev_id = device;
    emit CM_PLAYER_STOP (id);
  end
end

code/await Emit_Player_Sought_Event (var uint device,
                                     var uint id) -> none
do
  await async (device, id) do
    outer.evt_dev_id = device;
    emit CM_PLAYER_SOUGHT (id);
  end
end

code/await Emit_Player_Mouse_Click_Event (var uint device,
                                          var uint id,
                                          var int x,
                                          var int y,
                                          var int button,
                                          var bool press) -> none
do
  await async (device, id, x, y, button, press) do
    outer.evt_dev_id = device;
    emit CM_PLAYER_MOUSE_CLICK (id, x, y, button, press);
  end
end

code/await Input_Events_Manager (none) -> none
do
  par do
    /* KEY */
    var uint device;
    var uint id;
    var _char_ptr_ext key;
    var bool press;
    pool [] Emit_Scene_Key_Event scene_key_event_pool;
    every (device, id, key, press) in outer.create_evt_scene_key do
      spawn Emit_Scene_Key_Event (device, id, key, press)
                                  in scene_key_event_pool;
    end
  with
    /* MOUSE CLICKED */
    var uint device = 0;
    var uint id = 0;
    var int x = 0;
    var int y = 0;
    var int button = 0;
    var bool press = false;

    par do
      pool [] Emit_Scene_Mouse_Click_Event scene_mouse_click_event_pool;
      every (device, id, x, y, button, press)
                                   in outer.create_evt_scene_mouse_clicked do
        spawn Emit_Scene_Mouse_Click_Event (device, id, x, y, button, press)
                                            in scene_mouse_click_event_pool;
      end
    with
      pool [] Emit_Player_Mouse_Click_Event player_mouse_click_event_pool;
      every (device, id, x, y, button, press)
                                   in outer.create_evt_player_mouse_clicked do
        spawn Emit_Player_Mouse_Click_Event (device, id, x, y, button, press)
                                            in player_mouse_click_event_pool;
      end
    end
  end
end

code/tight Has_Mapping (var _char&& evt,
                        var& []byte role,
                        var bool is_local) -> bool
do
  var bool has_mapping = false;
  has_mapping = [[ has_mapping (@evt, @role, @is_local) ]];

  escape has_mapping;
end

code/tight Get_Mapping (var _char&& evt, var& []byte mapping) -> none
do
  [[
    map = get_mapping (@evt)
    if map ~= nil and map[3] == CLIENT.role.name then
      map = map[4]
    else
      map = ''
    end
  ]]

  mapping = [] .. [[ map ]];
end
